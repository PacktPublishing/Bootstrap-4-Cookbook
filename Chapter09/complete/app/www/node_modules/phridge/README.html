<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">
    <title>
        My default title
    </title>

    <!-- Bootstrap core CSS -->
    <link href="css/main.css" rel="stylesheet">

</head>

<body>

    <nav class="navbar navbar-toggleable-md navbar-dark bg-faded">
  <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
  <span class="navbar-toggler-icon"></span>
  </button>
  <a class="navbar-brand" href="index.html">Chapter 9</a>
  <div class="collapse navbar-collapse" id="navbarsExampleDefault">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item active">
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="http://example.com" id="dropdown01" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Recipes</a>
          <div class="dropdown-menu" aria-labelledby="dropdown01">
            <a class="dropdown-item" href="recipe09-01">1 - Customizing Bootstrap Builds by Cherry-picking Sass Partials</a>
            <a class="dropdown-item" href="recipe09-02">2 - Cleaning up unused CSS with UnCSS and Grunt</a>
            <a class="dropdown-item" href="recipe09-03">3 - Removing CSS comments with grunt-strip-css-comments</a>
          </div>
        </li>
      </li>
    </ul>
  </div>
</nav>

        <h1>phridge</h1><p><strong>A bridge between <a href="http://nodejs.org/">node</a> and <a href="http://phantomjs.org/">PhantomJS</a>.</strong></p>
<p><a href="https://www.npmjs.com/package/phridge"><img src="https://img.shields.io/npm/v/phridge.svg" alt=""></a>
<a href="https://www.npmjs.com/package/phridge"><img src="https://img.shields.io/npm/dm/phridge.svg" alt=""></a>
<a href="https://david-dm.org/peerigon/phridge"><img src="https://david-dm.org/peerigon/phridge.svg" alt="Dependency Status"></a>
<a href="https://travis-ci.org/peerigon/phridge"><img src="https://travis-ci.org/peerigon/phridge.svg?branch=master" alt="Build Status"></a>
<a href="https://Coveralls.io/r/peerigon/phridge?branch=master"><img src="https://img.shields.io/coveralls/peerigon/phridge.svg" alt="Coverage Status"></a></p>
<p>Working with PhantomJS in node is a bit cumbersome since you need to spawn a new PhantomJS process for every single task. However, spawning a new process is quite expensive and thus can slow down your application significantly.</p>
<p>phridge provides an api to easily</p>
<ul>
<li>spawn new PhantomJS processes</li>
<li>run functions with arguments inside PhantomJS</li>
<li>return results from PhantomJS to node</li>
<li>manage long-running PhantomJS instances</li>
</ul>
<p>Unlike other node-PhantomJS bridges phridge provides a way to run code directly inside PhantomJS instead of turning every call and assignment into an async operation.</p>
<p>phridge uses PhantomJS&#39; stdin and stdout for <a href="http://en.wikipedia.org/wiki/Inter-process_communication">inter-process communication</a>. It stringifies the given function, passes it to PhantomJS via stdin, executes it in the PhantomJS environment and passes back the results via stdout. Thus you can write your PhantomJS scripts inside your node modules in a clean and synchronous way.</p>
<p>Instead of ...</p>
<pre><code class="language-javascript">phantom.addCookie(&quot;cookie_name&quot;, &quot;cookie_value&quot;, &quot;localhost&quot;, function () {
    phantom.createPage(function (page) {
        page.set(&quot;customHeaders.Referer&quot;, &quot;http://google.com&quot;, function () {
            page.set(
                &quot;settings.userAgent&quot;,
                &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)&quot;,
                function () {
                    page.open(&quot;http://localhost:9901/cookie&quot;, function (status) {
                        page.evaluate(function (selector) {
                            return document.querySelector(selector).innerText;
                        }, function (text) {
                            console.log(&quot;The element contains the following text: &quot;+ text)
                        }, &quot;h1&quot;);
                    });
                }
            );
        });
    });
});
</code></pre>
<p>... you can write ...</p>
<pre><code class="language-javascript">// node
phantom.run(&quot;h1&quot;, function (selector, resolve) {
    // this code runs inside PhantomJS

    phantom.addCookie(&quot;cookie_name&quot;, &quot;cookie_value&quot;, &quot;localhost&quot;);

    var page = webpage.create();
    page.customHeaders = {
        Referer: &quot;http://google.com&quot;
    };
    page.settings = {
        userAgent: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)&quot;
    };
    page.open(&quot;http://www.google.com&quot;, function () {
        var text = page.evaluate(function (selector) {
            return document.querySelector(selector).innerText;
        }, selector);

        // resolve the promise and pass &#39;text&#39; back to node 
        resolve(text);
    });
}).then(function (text) {
    // inside node again
    console.log(&quot;The element contains the following text: &quot; + text);
});
</code></pre>
<p>Please note that the <code>phantom</code>-object provided by phridge is completely different to the <code>phantom</code>-object inside PhantomJS. So is the <code>page</code>-object. <a href="#api-phantom">Check out the api</a> for further information.</p>
<p><br></p>
<h2>Installation</h2><p><code>npm install phridge</code></p>
<p><br></p>
<h2>Examples</h2><h3>Spawn a new PhantomJS process</h3><pre><code class="language-javascript">phridge.spawn({
    proxyAuth: &quot;john:1234&quot;,
    loadImages: false,
    // passing CLI-style options does also work
    &quot;--remote-debugger-port&quot;: 8888
}).then(function (phantom) {
    // phantom is now a reference to a specific PhantomJS process
});
</code></pre>
<p><code>phridge.spawn()</code> takes an object which will be passed as config to PhantomJS. Check out <a href="http://phantomjs.org/api/command-line.html">their documentation</a> for a detailed overview of options. CLI-style options are added as they are, so be sure to escape the space character.</p>
<p><em>Please note: There are <a href="https://github.com/peerigon/phridge/issues/31">known issues</a> of PhantomJS that some config options are only supported in CLI-style.</em></p>
<h3>Run any function inside PhantomJS</h3><pre><code class="language-javascript">phantom.run(function () {
    console.log(&quot;Hi from PhantomJS&quot;);
});
</code></pre>
<p>phridge stringifies the given function, sends it to PhantomJS and evals it again. Hence you can&#39;t use scope variables:</p>
<pre><code class="language-javascript">var someVar = &quot;hi&quot;;

phantom.run(function () {
    console.log(someVar); // throws a ReferenceError
});
</code></pre>
<h3>Passing arguments</h3><p>You can also pass arguments to the PhantomJS process:</p>
<pre><code class="language-javascript">phantom.run(&quot;hi&quot;, 2, {}, function (string, number, object) {
    console.log(string, number, object); // &#39;hi&#39;, 2, [object Object]
});
</code></pre>
<p>Arguments are stringified by <code>JSON.stringify()</code>, so be sure to use JSON-valid objects.</p>
<h3>Returning results</h3><p>The given function can run sync and async. However, the <code>run()</code> method itself will always run async as it needs to wait for the process to respond.</p>
<p><strong>Sync</strong></p>
<pre><code class="language-javascript">phantom.run(function () {
    return Math.PI;
}).then(function (pi) {
    console.log(pi === Math.PI); // true
});
</code></pre>
<p><strong>Async</strong></p>
<pre><code class="language-javascript">phantom.run(function (resolve) {
    setTimeout(function () {
        resolve(&quot;after 500 ms&quot;);
    }, 500);
}).then(function (msg) {
    console.log(msg); // &#39;after 500 ms&#39;
});
</code></pre>
<p>Results are also stringified by <code>JSON.stringify()</code>, so returning application objects with functions won&#39;t work.</p>
<pre><code class="language-javascript">phantom.run(function () {
    ...
    // doesn&#39;t work because page is not a JSON-valid object
    return page;
});
</code></pre>
<h3>Returning errors</h3><p>Errors can be returned by using the <code>throw</code> keyword or by calling the <code>reject</code> function. Both ways will reject the promise returned by <code>run()</code>.</p>
<p><strong>Sync</strong></p>
<pre><code class="language-javascript">phantom.run(function () {
    throw new Error(&quot;An unknown error occured&quot;);
}).catch(function (err) {
    console.log(err); // &#39;An unknown error occured&#39;
});
</code></pre>
<p><strong>Async</strong></p>
<pre><code class="language-javascript">phantom.run(function (resolve, reject) {
    setTimeout(function () {
        reject(new Error(&quot;An unknown error occured&quot;));
    }, 500);
}).catch(function (err) {
    console.log(err); // &#39;An unknown error occured&#39;
});
</code></pre>
<h3>Async methods with arguments</h3><p><code>resolve</code> and <code>reject</code> are just appended to the regular arguments:</p>
<pre><code class="language-javascript">phantom.run(1, 2, 3, function (one, two, three, resolve, reject) {

});
</code></pre>
<h3>Persisting states inside PhantomJS</h3><p>Since the function passed to <code>phantom.run()</code> can&#39;t declare variables in the global scope, it is impossible to maintain state in PhantomJS. That&#39;s why <code>phantom.run()</code> calls all functions on the same context object. Thus you can easily store state variables.</p>
<pre><code class="language-javascript">phantom.run(function () {
    this.message = &quot;Hello from the first call&quot;;
}).then(function () {
    phantom.run(function () {
        console.log(this.message); // &#39;Hello from the first call&#39;
    });
});
</code></pre>
<p>For further convenience all PhantomJS modules are already available in the global scope.</p>
<pre><code class="language-javascript">phantom.run(function () {
    console.log(webpage);           // [object Object]
    console.log(system);            // [object Object]
    console.log(fs);                // [object Object]
    console.log(webserver);         // [object Object]
    console.log(child_process);     // [object Object]
});
</code></pre>
<h3>Working in a page context</h3><p>Most of the time its more useful to work in a specific webpage context. This is done by creating a Page via <code>phantom.createPage()</code> which calls internally <code>require(&quot;webpage&quot;).create()</code>. The returned page wrapper will then execute all functions bound to a PhantomJS <a href="http://phantomjs.org/api/webpage/">webpage instance</a>. </p>
<pre><code class="language-javascript">var page = phantom.createPage();

page.run(function (resolve, reject) {
    // `this` is now a webpage instance
    this.open(&quot;http://example.com&quot;, function (status) {
        if (status !== &quot;success&quot;) {
            return reject(new Error(&quot;Cannot load &quot; + this.url));
        }
        resolve();
    });
});
</code></pre>
<p>And for the busy ones: You can just call <code>phantom.openPage(url)</code> which is basically the same as above:</p>
<pre><code class="language-javascript">phantom.openPage(&quot;http://example.com&quot;).then(function (page) {
    console.log(&quot;Example loaded&quot;);
});
</code></pre>
<h3>Cleaning up</h3><p>If you don&#39;t need a particular page anymore, just call:</p>
<pre><code class="language-javascript">page.dispose().then(function () {
    console.log(&quot;page disposed&quot;);
});
</code></pre>
<p>This will clean up all page references inside PhantomJS.</p>
<p>If you don&#39;t need the whole process anymore call</p>
<pre><code class="language-javascript">phantom.dispose().then(function () {
    console.log(&quot;process terminated&quot;);
});
</code></pre>
<p>which will terminate the process cleanly by calling <code>phantom.exit(0)</code> internally. You don&#39;t need to dispose all pages manuallly when you call <code>phantom.dispose()</code>.</p>
<p>However, calling</p>
<pre><code class="language-javascript">phridge.disposeAll().then(function () {
    console.log(&quot;All processes created by phridge.spawn() have been terminated&quot;);
});
</code></pre>
<p>will terminate all processes.</p>
<p><strong>I strongly recommend to call</strong> <code>phridge.disposeAll()</code> <strong>when the node process exits as this is the only way to ensure that all child processes terminate as well.</strong> Since <code>disposeAll()</code> is async it is not safe to call it on <code>process.on(&quot;exit&quot;)</code>. It is better to call it on <code>SIGINT</code>, <code>SIGTERM</code> and within your regular exit flow.</p>
<p><br></p>
<h2>API</h2><h3>phridge</h3><h4>.spawn(config?): Promise → Phantom</h4><p>Spawns a new PhantomJS process with the given config. <a href="http://phantomjs.org/api/command-line.html">Read the PhantomJS documentation</a> for all available config options. Use camelCase style for option names. The promise will be fulfilled with an instance of <code>Phantom</code>.</p>
<h4>.disposeAll(): Promise</h4><p>Terminates all PhantomJS processes that have been spawned. The promise will be fulfilled when all child processes emitted an <code>exit</code>-event.</p>
<h4>.config.stdout: Stream = process.stdout</h4><p>Destination stream where PhantomJS&#39; <a href="#phantom-childprocess-cleanstdout">clean stdout</a> will be piped to. Set it <code>null</code> if you don&#39;t want it. Changing the value does not affect processes that have already been spawned.</p>
<h4>.config.stderr: Stream = process.stderr</h4><p>Destination stream where PhantomJS&#39; stderr will be piped to. Set it <code>null</code> if you don&#39;t want it. Changing the value does not affect processes that have already been spawned.</p>
<hr>
<h3><a name="api-phantom"></a>Phantom.prototype</h3><h4>.childProcess: ChildProcess</h4><p>A reference to the <a href="http://nodejs.org/api/child_process.html#child_process_class_childprocess">ChildProcess</a>-instance.</p>
<h4><a name="phantom-childprocess-cleanstdout"></a> .childProcess.cleanStdout: ReadableStream</h4><p>phridge extends the <a href="http://nodejs.org/api/child_process.html#child_process_class_childprocess">ChildProcess</a>-instance by a new stream called <code>cleanStdout</code>. This stream is piped to <code>process.stdout</code> by default. It provides all data not dedicated to phridge. Streaming data is considered to be dedicated to phridge when the new line is preceded by the classifier string <code>&quot;message to node: &quot;</code>.</p>
<h4><a name="phantom-run"></a>.run(args..., fn): Promise → *</h4><p>Stringifies <code>fn</code>, sends it to PhantomJS and executes it there again. <code>args...</code> are stringified using <code>JSON.stringify()</code> and passed to <code>fn</code> again. <code>fn</code> may simply <code>return</code> a result or <code>throw</code> an error or call <code>resolve()</code> or <code>reject()</code> respectively if it is asynchronous. phridge compares <code>fn.length</code> with the given number of arguments to determine whether <code>fn</code> is sync or async. The returned promise will be resolved with the result or rejected with the error.</p>
<h4>.createPage(): Page</h4><p>Creates a wrapper to execute code in the context of a specific <a href="http://phantomjs.org/api/webpage/">PhantomJS webpage</a>.</p>
<h4>.openPage(url): Promise → Page</h4><p>Calls <code>phantom.createPage()</code>, then <code>page.open(url, cb)</code> inside PhantomJS and resolves when <code>cb</code> is called. If the returned <code>status</code> is not <code>&quot;success&quot;</code> the promise will be rejected.</p>
<h4>.dispose(): Promise</h4><p>Calls <code>phantom.exit(0)</code> inside PhantomJS and resolves when the child process emits an <code>exit</code>-event.</p>
<h3>Events</h3><h4>unexpectedExit</h4><p>Will be emitted when PhantomJS exited without a call to <code>phantom.dispose()</code> or one of its std streams emitted an <code>error</code> event. This event may be fired on some OS when the process group receives a <code>SIGINT</code> or <code>SIGTERM</code> (see <a href="https://github.com/peerigon/phridge/pull/35">#35</a>).</p>
<p>When an <code>unexpectedExit</code> event is encountered, the <code>phantom</code> instance will be unusable and therefore automatically disposed. Usually you don&#39;t need to listen for this event.</p>
<hr>
<h3>Page.prototype</h3><h4>.phantom: Phantom</h4><p>A reference to the parent <a href="#api-phantom"><code>Phantom</code></a> instance.</p>
<h4>.run(args..., fn): Promise → *</h4><p>Calls <code>fn</code> on the context of a PhantomJS page object. See <a href="#phantom-run"><code>phantom.run()</code></a> for further information.</p>
<h4>.dispose(): Promise</h4><p>Cleans up this page instance by calling <code>page.close()</code></p>
<p><br></p>
<h2>Contributing</h2><p>From opening a bug report to creating a pull request: <strong>every contribution is appreciated and welcome</strong>. If you&#39;re planing to implement a new feature or change the api please create an issue first. This way we can ensure that your precious work is not in vain.</p>
<p>All pull requests should have 100% test coverage (with notable exceptions) and need to pass all tests.</p>
<ul>
<li>Call <code>npm test</code> to run the unit tests</li>
<li>Call <code>npm run coverage</code> to check the test coverage (using <a href="https://github.com/gotwarlost/istanbul">istanbul</a>)  </li>
</ul>
<p><br></p>
<h2>License</h2><p>Unlicense</p>

	 <!-- Bootstrap core JavaScript
 ================================================== -->
 <!-- Placed at the end of the document so the pages load faster -->
     <script src="js/jquery.js"></script>
    <script src="js/tether.js"></script>
    <script src="js/bootstrap.js"></script>

</body>
</html>