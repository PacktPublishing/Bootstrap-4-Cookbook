<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">
    <title>
        My default title
    </title>

    <!-- Bootstrap core CSS -->
    <link href="css/main.css" rel="stylesheet">

</head>

<body>

    <nav class="navbar navbar-toggleable-md navbar-dark bg-faded">
  <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
  <span class="navbar-toggler-icon"></span>
  </button>
  <a class="navbar-brand" href="index.html">Chapter 9</a>
  <div class="collapse navbar-collapse" id="navbarsExampleDefault">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item active">
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="http://example.com" id="dropdown01" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Recipes</a>
          <div class="dropdown-menu" aria-labelledby="dropdown01">
            <a class="dropdown-item" href="recipe09-01">1 - Customizing Bootstrap Builds by Cherry-picking Sass Partials</a>
            <a class="dropdown-item" href="recipe09-02">2 - Cleaning up unused CSS with UnCSS and Grunt</a>
            <a class="dropdown-item" href="recipe09-03">3 - Removing CSS comments with grunt-strip-css-comments</a>
          </div>
        </li>
      </li>
    </ul>
  </div>
</nav>

        <h1>qs</h1><p>A querystring parsing and stringifying library with some added security.</p>
<p><a href="http://travis-ci.org/ljharb/qs"><img src="https://api.travis-ci.org/ljharb/qs.svg" alt="Build Status"></a></p>
<p>Lead Maintainer: <a href="https://github.com/ljharb">Jordan Harband</a></p>
<p>The <strong>qs</strong> module was originally created and maintained by <a href="https://github.com/visionmedia/node-querystring">TJ Holowaychuk</a>.</p>
<h2>Usage</h2><pre><code class="language-javascript">var qs = require(&#39;qs&#39;);
var assert = require(&#39;assert&#39;);

var obj = qs.parse(&#39;a=c&#39;);
assert.deepEqual(obj, { a: &#39;c&#39; });

var str = qs.stringify(obj);
assert.equal(str, &#39;a=c&#39;);
</code></pre>
<h3>Parsing Objects</h3><p><a href="#preventEval"></a></p>
<pre><code class="language-javascript">qs.parse(string, [options]);
</code></pre>
<p><strong>qs</strong> allows you to create nested objects within your query strings, by surrounding the name of sub-keys with square brackets <code>[]</code>.
For example, the string <code>&#39;foo[bar]=baz&#39;</code> converts to:</p>
<pre><code class="language-javascript">assert.deepEqual(qs.parse(&#39;foo[bar]=baz&#39;), {
  foo: {
    bar: &#39;baz&#39;
  }
});
</code></pre>
<p>When using the <code>plainObjects</code> option the parsed value is returned as a null object, created via <code>Object.create(null)</code> and as such you should be aware that prototype methods will not exist on it and a user may set those names to whatever value they like:</p>
<pre><code class="language-javascript">var nullObject = qs.parse(&#39;a[hasOwnProperty]=b&#39;, { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: &#39;b&#39; } });
</code></pre>
<p>By default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use <code>plainObjects</code> as mentioned above, or set <code>allowPrototypes</code> to <code>true</code> which will allow user input to overwrite those properties. <em>WARNING</em> It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.</p>
<pre><code class="language-javascript">var protoObject = qs.parse(&#39;a[hasOwnProperty]=b&#39;, { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: &#39;b&#39; } });
</code></pre>
<p>URI encoded strings work too:</p>
<pre><code class="language-javascript">assert.deepEqual(qs.parse(&#39;a%5Bb%5D=c&#39;), {
  a: { b: &#39;c&#39; }
});
</code></pre>
<p>You can also nest your objects, like <code>&#39;foo[bar][baz]=foobarbaz&#39;</code>:</p>
<pre><code class="language-javascript">assert.deepEqual(qs.parse(&#39;foo[bar][baz]=foobarbaz&#39;), {
  foo: {
    bar: {
      baz: &#39;foobarbaz&#39;
    }
  }
});
</code></pre>
<p>By default, when nesting objects <strong>qs</strong> will only parse up to 5 children deep. This means if you attempt to parse a string like
<code>&#39;a[b][c][d][e][f][g][h][i]=j&#39;</code> your resulting object will be:</p>
<pre><code class="language-javascript">var expected = {
  a: {
    b: {
      c: {
        d: {
          e: {
            f: {
              &#39;[g][h][i]&#39;: &#39;j&#39;
            }
          }
        }
      }
    }
  }
};
var string = &#39;a[b][c][d][e][f][g][h][i]=j&#39;;
assert.deepEqual(qs.parse(string), expected);
</code></pre>
<p>This depth can be overridden by passing a <code>depth</code> option to <code>qs.parse(string, [options])</code>:</p>
<pre><code class="language-javascript">var deep = qs.parse(&#39;a[b][c][d][e][f][g][h][i]=j&#39;, { depth: 1 });
assert.deepEqual(deep, { a: { b: { &#39;[c][d][e][f][g][h][i]&#39;: &#39;j&#39; } } });
</code></pre>
<p>The depth limit helps mitigate abuse when <strong>qs</strong> is used to parse user input, and it is recommended to keep it a reasonably small number.</p>
<p>For similar reasons, by default <strong>qs</strong> will only parse up to 1000 parameters. This can be overridden by passing a <code>parameterLimit</code> option:</p>
<pre><code class="language-javascript">var limited = qs.parse(&#39;a=b&amp;c=d&#39;, { parameterLimit: 1 });
assert.deepEqual(limited, { a: &#39;b&#39; });
</code></pre>
<p>An optional delimiter can also be passed:</p>
<pre><code class="language-javascript">var delimited = qs.parse(&#39;a=b;c=d&#39;, { delimiter: &#39;;&#39; });
assert.deepEqual(delimited, { a: &#39;b&#39;, c: &#39;d&#39; });
</code></pre>
<p>Delimiters can be a regular expression too:</p>
<pre><code class="language-javascript">var regexed = qs.parse(&#39;a=b;c=d,e=f&#39;, { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: &#39;b&#39;, c: &#39;d&#39;, e: &#39;f&#39; });
</code></pre>
<p>Option <code>allowDots</code> can be used to enable dot notation:</p>
<pre><code class="language-javascript">var withDots = qs.parse(&#39;a.b=c&#39;, { allowDots: true });
assert.deepEqual(withDots, { a: { b: &#39;c&#39; } });
</code></pre>
<h3>Parsing Arrays</h3><p><strong>qs</strong> can also parse arrays using a similar <code>[]</code> notation:</p>
<pre><code class="language-javascript">var withArray = qs.parse(&#39;a[]=b&amp;a[]=c&#39;);
assert.deepEqual(withArray, { a: [&#39;b&#39;, &#39;c&#39;] });
</code></pre>
<p>You may specify an index as well:</p>
<pre><code class="language-javascript">var withIndexes = qs.parse(&#39;a[1]=c&amp;a[0]=b&#39;);
assert.deepEqual(withIndexes, { a: [&#39;b&#39;, &#39;c&#39;] });
</code></pre>
<p>Note that the only difference between an index in an array and a key in an object is that the value between the brackets must be a number
to create an array. When creating arrays with specific indices, <strong>qs</strong> will compact a sparse array to only the existing values preserving
their order:</p>
<pre><code class="language-javascript">var noSparse = qs.parse(&#39;a[1]=b&amp;a[15]=c&#39;);
assert.deepEqual(noSparse, { a: [&#39;b&#39;, &#39;c&#39;] });
</code></pre>
<p>Note that an empty string is also a value, and will be preserved:</p>
<pre><code class="language-javascript">var withEmptyString = qs.parse(&#39;a[]=&amp;a[]=b&#39;);
assert.deepEqual(withEmptyString, { a: [&#39;&#39;, &#39;b&#39;] });

var withIndexedEmptyString = qs.parse(&#39;a[0]=b&amp;a[1]=&amp;a[2]=c&#39;);
assert.deepEqual(withIndexedEmptyString, { a: [&#39;b&#39;, &#39;&#39;, &#39;c&#39;] });
</code></pre>
<p><strong>qs</strong> will also limit specifying indices in an array to a maximum index of <code>20</code>. Any array members with an index of greater than <code>20</code> will
instead be converted to an object with the index as the key:</p>
<pre><code class="language-javascript">var withMaxIndex = qs.parse(&#39;a[100]=b&#39;);
assert.deepEqual(withMaxIndex, { a: { &#39;100&#39;: &#39;b&#39; } });
</code></pre>
<p>This limit can be overridden by passing an <code>arrayLimit</code> option:</p>
<pre><code class="language-javascript">var withArrayLimit = qs.parse(&#39;a[1]=b&#39;, { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { &#39;1&#39;: &#39;b&#39; } });
</code></pre>
<p>To disable array parsing entirely, set <code>parseArrays</code> to <code>false</code>.</p>
<pre><code class="language-javascript">var noParsingArrays = qs.parse(&#39;a[]=b&#39;, { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { &#39;0&#39;: &#39;b&#39; } });
</code></pre>
<p>If you mix notations, <strong>qs</strong> will merge the two items into an object:</p>
<pre><code class="language-javascript">var mixedNotation = qs.parse(&#39;a[0]=b&amp;a[b]=c&#39;);
assert.deepEqual(mixedNotation, { a: { &#39;0&#39;: &#39;b&#39;, b: &#39;c&#39; } });
</code></pre>
<p>You can also create arrays of objects:</p>
<pre><code class="language-javascript">var arraysOfObjects = qs.parse(&#39;a[][b]=c&#39;);
assert.deepEqual(arraysOfObjects, { a: [{ b: &#39;c&#39; }] });
</code></pre>
<h3>Stringifying</h3><p><a href="#preventEval"></a></p>
<pre><code class="language-javascript">qs.stringify(object, [options]);
</code></pre>
<p>When stringifying, <strong>qs</strong> by default URI encodes output. Objects are stringified as you would expect:</p>
<pre><code class="language-javascript">assert.equal(qs.stringify({ a: &#39;b&#39; }), &#39;a=b&#39;);
assert.equal(qs.stringify({ a: { b: &#39;c&#39; } }), &#39;a%5Bb%5D=c&#39;);
</code></pre>
<p>This encoding can be disabled by setting the <code>encode</code> option to <code>false</code>:</p>
<pre><code class="language-javascript">var unencoded = qs.stringify({ a: { b: &#39;c&#39; } }, { encode: false });
assert.equal(unencoded, &#39;a[b]=c&#39;);
</code></pre>
<p>This encoding can also be replaced by a custom encoding method set as <code>encoder</code> option:</p>
<pre><code class="language-javascript">var encoded = qs.stringify({ a: { b: &#39;c&#39; } }, { encoder: function (str) {
  // Passed in values `a`, `b`, `c`
  return // Return encoded string
}})
</code></pre>
<p><em>(Note: the <code>encoder</code> option does not apply if <code>encode</code> is <code>false</code>)</em></p>
<p>Analogue to the <code>encoder</code> there is a <code>decoder</code> option for <code>parse</code> to override decoding of properties and values:</p>
<pre><code class="language-javascript">var decoded = qs.parse(&#39;x=z&#39;, { decoder: function (str) {
  // Passed in values `x`, `z`
  return // Return decoded string
}})
</code></pre>
<p>Examples beyond this point will be shown as though the output is not URI encoded for clarity. Please note that the return values in these cases <em>will</em> be URI encoded during real usage.</p>
<p>When arrays are stringified, by default they are given explicit indices:</p>
<pre><code class="language-javascript">qs.stringify({ a: [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;] });
// &#39;a[0]=b&amp;a[1]=c&amp;a[2]=d&#39;
</code></pre>
<p>You may override this by setting the <code>indices</code> option to <code>false</code>:</p>
<pre><code class="language-javascript">qs.stringify({ a: [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;] }, { indices: false });
// &#39;a=b&amp;a=c&amp;a=d&#39;
</code></pre>
<p>You may use the <code>arrayFormat</code> option to specify the format of the output array:</p>
<pre><code class="language-javascript">qs.stringify({ a: [&#39;b&#39;, &#39;c&#39;] }, { arrayFormat: &#39;indices&#39; })
// &#39;a[0]=b&amp;a[1]=c&#39;
qs.stringify({ a: [&#39;b&#39;, &#39;c&#39;] }, { arrayFormat: &#39;brackets&#39; })
// &#39;a[]=b&amp;a[]=c&#39;
qs.stringify({ a: [&#39;b&#39;, &#39;c&#39;] }, { arrayFormat: &#39;repeat&#39; })
// &#39;a=b&amp;a=c&#39;
</code></pre>
<p>When objects are stringified, by default they use bracket notation:</p>
<pre><code class="language-javascript">qs.stringify({ a: { b: { c: &#39;d&#39;, e: &#39;f&#39; } } });
// &#39;a[b][c]=d&amp;a[b][e]=f&#39;
</code></pre>
<p>You may override this to use dot notation by setting the <code>allowDots</code> option to <code>true</code>:</p>
<pre><code class="language-javascript">qs.stringify({ a: { b: { c: &#39;d&#39;, e: &#39;f&#39; } } }, { allowDots: true });
// &#39;a.b.c=d&amp;a.b.e=f&#39;
</code></pre>
<p>Empty strings and null values will omit the value, but the equals sign (=) remains in place:</p>
<pre><code class="language-javascript">assert.equal(qs.stringify({ a: &#39;&#39; }), &#39;a=&#39;);
</code></pre>
<p>Key with no values (such as an empty object or array) will return nothing:</p>
<pre><code class="language-javascript">assert.equal(qs.stringify({ a: [] }), &#39;&#39;);
assert.equal(qs.stringify({ a: {} }), &#39;&#39;);
assert.equal(qs.stringify({ a: [{}] }), &#39;&#39;);
assert.equal(qs.stringify({ a: { b: []} }), &#39;&#39;);
assert.equal(qs.stringify({ a: { b: {}} }), &#39;&#39;);
</code></pre>
<p>Properties that are set to <code>undefined</code> will be omitted entirely:</p>
<pre><code class="language-javascript">assert.equal(qs.stringify({ a: null, b: undefined }), &#39;a=&#39;);
</code></pre>
<p>The delimiter may be overridden with stringify as well:</p>
<pre><code class="language-javascript">assert.equal(qs.stringify({ a: &#39;b&#39;, c: &#39;d&#39; }, { delimiter: &#39;;&#39; }), &#39;a=b;c=d&#39;);
</code></pre>
<p>If you only want to override the serialization of <code>Date</code> objects, you can provide a <code>serializeDate</code> option:</p>
<pre><code class="language-javascript">var date = new Date(7);
assert.equal(qs.stringify({ a: date }), &#39;a=1970-01-01T00:00:00.007Z&#39;.replace(/:/g, &#39;%3A&#39;));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    &#39;a=7&#39;
);
</code></pre>
<p>You may use the <code>sort</code> option to affect the order of parameter keys:</p>
<pre><code class="language-javascript">function alphabeticalSort(a, b) {
  return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: &#39;c&#39;, z: &#39;y&#39;, b : &#39;f&#39; }, { sort: alphabeticalSort }), &#39;a=c&amp;b=f&amp;z=y&#39;);
</code></pre>
<p>Finally, you can use the <code>filter</code> option to restrict which keys will be included in the stringified output.
If you pass a function, it will be called for each key to obtain the replacement value. Otherwise, if you
pass an array, it will be used to select properties and array indices for stringification:</p>
<pre><code class="language-javascript">function filterFunc(prefix, value) {
  if (prefix == &#39;b&#39;) {
    // Return an `undefined` value to omit a property.
    return;
  }
  if (prefix == &#39;e[f]&#39;) {
    return value.getTime();
  }
  if (prefix == &#39;e[g][0]&#39;) {
    return value * 2;
  }
  return value;
}
qs.stringify({ a: &#39;b&#39;, c: &#39;d&#39;, e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// &#39;a=b&amp;c=d&amp;e[f]=123&amp;e[g][0]=4&#39;
qs.stringify({ a: &#39;b&#39;, c: &#39;d&#39;, e: &#39;f&#39; }, { filter: [&#39;a&#39;, &#39;e&#39;] });
// &#39;a=b&amp;e=f&#39;
qs.stringify({ a: [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;], e: &#39;f&#39; }, { filter: [&#39;a&#39;, 0, 2] });
// &#39;a[0]=b&amp;a[2]=d&#39;
</code></pre>
<h3>Handling of <code>null</code> values</h3><p>By default, <code>null</code> values are treated like empty strings:</p>
<pre><code class="language-javascript">var withNull = qs.stringify({ a: null, b: &#39;&#39; });
assert.equal(withNull, &#39;a=&amp;b=&#39;);
</code></pre>
<p>Parsing does not distinguish between parameters with and without equal signs. Both are converted to empty strings.</p>
<pre><code class="language-javascript">var equalsInsensitive = qs.parse(&#39;a&amp;b=&#39;);
assert.deepEqual(equalsInsensitive, { a: &#39;&#39;, b: &#39;&#39; });
</code></pre>
<p>To distinguish between <code>null</code> values and empty strings use the <code>strictNullHandling</code> flag. In the result string the <code>null</code>
values have no <code>=</code> sign:</p>
<pre><code class="language-javascript">var strictNull = qs.stringify({ a: null, b: &#39;&#39; }, { strictNullHandling: true });
assert.equal(strictNull, &#39;a&amp;b=&#39;);
</code></pre>
<p>To parse values without <code>=</code> back to <code>null</code> use the <code>strictNullHandling</code> flag:</p>
<pre><code class="language-javascript">var parsedStrictNull = qs.parse(&#39;a&amp;b=&#39;, { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: &#39;&#39; });
</code></pre>
<p>To completely skip rendering keys with <code>null</code> values, use the <code>skipNulls</code> flag:</p>
<pre><code class="language-javascript">var nullsSkipped = qs.stringify({ a: &#39;b&#39;, c: null}, { skipNulls: true });
assert.equal(nullsSkipped, &#39;a=b&#39;);
</code></pre>
<h3>Dealing with special character sets</h3><p>By default the encoding and decoding of characters is done in <code>utf-8</code>. If you 
wish to encode querystrings to a different character set (i.e.
<a href="https://en.wikipedia.org/wiki/Shift_JIS">Shift JIS</a>) you can use the
<a href="https://github.com/martinheidegger/qs-iconv"><code>qs-iconv</code></a> library:</p>
<pre><code class="language-javascript">var encoder = require(&#39;qs-iconv/encoder&#39;)(&#39;shift_jis&#39;);
var shiftJISEncoded = qs.stringify({ a: &#39;こんにちは！&#39; }, { encoder: encoder });
assert.equal(shiftJISEncoded, &#39;a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I&#39;);
</code></pre>
<p>This also works for decoding of query strings:</p>
<pre><code class="language-javascript">var decoder = require(&#39;qs-iconv/decoder&#39;)(&#39;shift_jis&#39;);
var obj = qs.parse(&#39;a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I&#39;, { decoder: decoder });
assert.deepEqual(obj, { a: &#39;こんにちは！&#39; });
</code></pre>
<h3>RFC 3986 and RFC 1738 space encoding</h3><p>RFC3986 used as default option and encodes &#39; &#39; to <em>%20</em> which is backward compatible.
In the same time, output can be stringified as per RFC1738 with &#39; &#39; equal to &#39;+&#39;.</p>
<pre><code>assert.equal(qs.stringify({ a: &#39;b c&#39; }), &#39;a=b%20c&#39;);
assert.equal(qs.stringify({ a: &#39;b c&#39; }, { format : &#39;RFC3986&#39; }), &#39;a=b%20c&#39;);
assert.equal(qs.stringify({ a: &#39;b c&#39; }, { format : &#39;RFC1738&#39; }), &#39;a=b+c&#39;);
</code></pre>

	 <!-- Bootstrap core JavaScript
 ================================================== -->
 <!-- Placed at the end of the document so the pages load faster -->
     <script src="js/jquery.js"></script>
    <script src="js/tether.js"></script>
    <script src="js/bootstrap.js"></script>

</body>
</html>