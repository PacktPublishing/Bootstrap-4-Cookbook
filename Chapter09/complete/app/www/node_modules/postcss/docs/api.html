<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">
    <title>
        My default title
    </title>

    <!-- Bootstrap core CSS -->
    <link href="css/main.css" rel="stylesheet">

</head>

<body>

    <nav class="navbar navbar-toggleable-md navbar-dark bg-faded">
  <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
  <span class="navbar-toggler-icon"></span>
  </button>
  <a class="navbar-brand" href="index.html">Chapter 9</a>
  <div class="collapse navbar-collapse" id="navbarsExampleDefault">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item active">
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="http://example.com" id="dropdown01" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Recipes</a>
          <div class="dropdown-menu" aria-labelledby="dropdown01">
            <a class="dropdown-item" href="recipe09-01">1 - Customizing Bootstrap Builds by Cherry-picking Sass Partials</a>
            <a class="dropdown-item" href="recipe09-02">2 - Cleaning up unused CSS with UnCSS and Grunt</a>
            <a class="dropdown-item" href="recipe09-03">3 - Removing CSS comments with grunt-strip-css-comments</a>
          </div>
        </li>
      </li>
    </ul>
  </div>
</nav>

        <h1>PostCSS API</h1><ul>
<li><a href="#postcss-function"><code>postcss</code> function</a></li>
<li><a href="#processor-class"><code>Processor</code> class</a></li>
<li><a href="#lazyresult-class"><code>LazyResult</code> class</a></li>
<li><a href="#result-class"><code>Result</code> class</a></li>
<li><a href="#warning-class"><code>Warning</code> class</a></li>
<li><a href="#csssyntaxerror-class"><code>CssSyntaxError</code> class</a></li>
<li><a href="#vendor-module">Vendor module</a></li>
<li><a href="#list-module">List module</a></li>
<li><a href="#input-class"><code>Input</code> class</a></li>
<li><a href="#nodes-common-methods">Nodes common methods</a></li>
<li><a href="#containers-common-methods">Containers common methods</a></li>
<li><a href="#root-node"><code>Root</code> node</a></li>
<li><a href="#atrule-node"><code>AtRule</code> node</a></li>
<li><a href="#rule-node"><code>Rule</code> node</a></li>
<li><a href="#declaration-node"><code>Declaration</code> node</a></li>
<li><a href="#comment-node"><code>Comment</code> node</a></li>
</ul>
<h2><code>postcss</code> function</h2><p>The <code>postcss</code> function is the main entry point for PostCSS.</p>
<pre><code class="language-js">var postcss = require(&#39;postcss&#39;);
</code></pre>
<p>For those using <a href="http://www.typescriptlang.org/">TypeScript</a>, typings are already provided in this package.
Simply, import PostCSS as you would normally.</p>
<pre><code class="language-ts">import * as postcss from &#39;postcss&#39;;
</code></pre>
<h3><code>postcss(plugins)</code></h3><p>Returns a new <a href="#processor-class"><code>Processor</code></a> instance that will apply <code>plugins</code>
as CSS processors.</p>
<pre><code class="language-js">postcss([autoprefixer, cssnext, cssgrace]).process(css).css;
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>plugins (array)</code>: list of PostCSS plugins to be included as processors.</li>
</ul>
<p>Plugins can also be included with the <a href="#processoruseplugin"><code>Processor#use</code></a> method.
See its description below for details about plugin formats.</p>
<h3><code>postcss.parse(css, opts)</code></h3><p>Parses source <code>css</code> and returns a new <code>Root</code> node, which contains
the source CSS nodes.</p>
<pre><code class="language-js">// Simple CSS concatenation with source map support
var root1 = postcss.parse(css1, { from: file1 });
var root2 = postcss.parse(css2, { from: file2 });
root1.append(root2).toResult().css;
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>css (string|#toString)</code>: String with input CSS or any object
with <code>toString()</code> method, like a Buffer.</li>
<li><code>opts (object) optional</code>: options:<ul>
<li><code>from</code>: the path to the source CSS file. You should always set <code>from</code>,
because it is used in map generation and in syntax error messages.</li>
<li><code>map</code>: an object of <a href="https://github.com/postcss/postcss/blob/master/docs/source-maps.md">source map options</a>.
Only <code>map.prev</code> is used in <code>parse</code>.</li>
</ul>
</li>
</ul>
<h3><code>postcss.plugin(name, initializer)</code></h3><p>Creates a PostCSS plugin with a standard API.</p>
<pre><code class="language-js">var remove = postcss.plugin(&#39;postcss-remove&#39;, function (opts) {
    opts = opts || {};
    var filter = opts.prop || &#39;z-index&#39;;
    return function (css, result) {
        css.walkDecls(filter, function (decl) {
            decl.remove();
        });
    };
});

postcss([ remove ])                   // with default options
postcss([ remove({ prop: &#39;color&#39; })]) // with options
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>name (string)</code>: PostCSS plugin name. Same as in <code>name</code> property
in <code>package.json</code>. It will be saved in <code>plugin.postcssPlugin</code> property.</li>
<li><code>initializer  (function)</code>: will receive plugin options and should return
functions to modify nodes in input CSS.</li>
</ul>
<p>The newly-wrapped function will provide both the name and PostCSS
version of the plugin:</p>
<pre><code class="language-js">var processor = postcss([replace]);
processor.plugins[0].postcssPlugin  //=&gt; &#39;postcss-replace&#39;
processor.plugins[0].postcssVersion //=&gt; &#39;4.1.0&#39;
</code></pre>
<p>The plugin function receives 2 arguments: <a href="#root-node"><code>Root</code> node</a> and <a href="#result-class"><code>Result</code></a> instance.
The function should mutate the provided <code>Root</code> node. Alternatively, you can
create a new <code>Root</code> node and override the <code>result.root</code> property.</p>
<pre><code class="language-js">var cleaner = postcss.plugin(&#39;postcss-cleaner&#39;, function () {
    return function (css, result) {
        result.root = postcss.root();
    };
});
</code></pre>
<p>As a convenience, plugins also expose a <code>process</code> method so that you can use
them as standalone tools.</p>
<pre><code class="language-js">cleaner.process(css, options);
// This is equivalent to:
postcss([ cleaner(options) ]).process(css);
</code></pre>
<p>Asynchronous plugins should return a <code>Promise</code> instance.</p>
<pre><code class="language-js">postcss.plugin(&#39;postcss-import&#39;, function () {
    return function (css, result) {
        return new Promise(function (resolve, reject) {
            fs.readFile(&#39;base.css&#39;, function (base) {
                css.prepend(base);
                resolve();
            });
        });
    };
});
</code></pre>
<p>Add warnings using the <a href="#nodewarnresult-message"><code>Node#warn()</code></a> method.</p>
<pre><code class="language-js">postcss.plugin(&#39;postcss-caniuse-test&#39;, function () {
    return function (css, result) {
        css.walkDecls(function (decl) {
            if ( !caniuse.support(decl.prop) ) {
                decl.warn(result,
                  &#39;Some browsers do not support &#39; + decl.prop);
            }
        });
    };
});
</code></pre>
<p>Send data to other plugins using the <a href="#resultmessages"><code>Result#messages</code></a> array.</p>
<h3><code>postcss.root(props)</code></h3><p>Creates a new <a href="#root-node"><code>Root</code> node</a>.</p>
<pre><code class="language-js">postcss.root({ after: &#39;\n&#39; }).toString() //=&gt; &quot;\n&quot;
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object) optional</code>: properties for the new root node.</li>
</ul>
<h3><code>postcss.atRule(props)</code></h3><p>Creates a new <a href="#atrule-node"><code>AtRule</code> node</a>.</p>
<pre><code class="language-js">postcss.atRule({ name: &#39;charset&#39; }).toString() //=&gt; &quot;@charset&quot;
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object) optional</code>: properties for the new at-rule node.</li>
</ul>
<h3><code>postcss.rule(props)</code></h3><p>Creates a new <a href="#rule-node"><code>Rule</code> node</a>.</p>
<pre><code class="language-js">postcss.rule({ selector: &#39;a&#39; }).toString() //=&gt; &quot;a {\n}&quot;
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object) optional</code>: properties for the new rule node.</li>
</ul>
<h3><code>postcss.decl(props)</code></h3><p>Creates a new <a href="#declaration-node"><code>Declaration</code> node</a>.</p>
<pre><code class="language-js">postcss.decl({ prop: &#39;color&#39;, value: &#39;black&#39; }).toString() //=&gt; &quot;color: black&quot;
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object) optional</code>: properties for the new declaration node.</li>
</ul>
<h3><code>postcss.comment(props)</code></h3><p>Creates a new <a href="#comment-node"><code>Comment</code> node</a>.</p>
<pre><code class="language-js">postcss.comment({ text: &#39;test&#39; }).toString() //=&gt; &quot;/* test */&quot;
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object) optional</code>: properties for the new comment node.</li>
</ul>
<h3><code>postcss.vendor</code></h3><p>Contains the <a href="#vendor-module">Vendor module</a>.</p>
<pre><code class="language-js">postcss.vendor.unprefixed(&#39;-moz-tab&#39;) //=&gt; [&#39;tab&#39;]
</code></pre>
<h3><code>postcss.list</code></h3><p>Contains the <a href="#list-module">List module</a>.</p>
<pre><code class="language-js">postcss.list.space(&#39;5px calc(10% + 5px)&#39;) //=&gt; [&#39;5px&#39;, &#39;calc(10% + 5px)&#39;]
</code></pre>
<h3><code>postcss.stringify(node, builder)</code></h3><p>Default function to convert a node tree into a CSS string.</p>
<h2><code>Processor</code> class</h2><p>A <code>Processor</code> instance contains plugins to process CSS. Create
one <code>Processor</code> instance, initialize its plugins, and then use that instance
on numerous CSS files.</p>
<pre><code class="language-js">var processor = postcss([autoprefixer, cssnext, cssgrace]);
processor.process(css1).css;
processor.process(css2).css;
</code></pre>
<h3><code>processor.use(plugin)</code></h3><p>Adds a plugin to be used as a CSS processor.</p>
<pre><code class="language-js">var processor = postcss();
processor.use(autoprefixer()).use(cssnext()).use(cssgrace());
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>plugin (function|#postcss|Processor)</code>: PostCSS plugin. It can be in three
formats:<ul>
<li>A plugin created by <a href="#postcsspluginname-initializer"><code>postcss.plugin()</code></a> method.</li>
<li>A function. PostCSS will pass the function a <a href="#root-node"><code>Root</code> node</a>
as the first argument and current <a href="#result-class"><code>Result</code></a> instance as the second.</li>
<li>An object with a <code>postcss</code> method. PostCSS will use that method
as described in #2.</li>
<li>Another <code>Processor</code> instance. PostCSS will copy plugins
from that instance into this one.</li>
</ul>
</li>
</ul>
<p>Plugins can also be added by passing them as arguments when creating
a <code>postcss</code> instance (see <a href="#postcssplugins"><code>postcss(plugins)</code></a>).</p>
<p>Asynchronous Plugins should return a <code>Promise</code> instance.</p>
<h3><code>processor.process(css, opts)</code></h3><p>Parses source CSS and returns a <a href="#lazyresult-class"><code>LazyResult</code></a> instance. Because some plugins
can be asynchronous it doesn’t make any transformations. Transformations will
be applied in the <code>LazyResult</code>’s methods.</p>
<pre><code class="language-js">processor.process(css, { from: &#39;a.css&#39;, to: &#39;a.out.css&#39; }).then(function (result) {
    console.log(result.css);
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>css (string|#toString|Result)</code>: String with input CSS or any object
with a <code>toString()</code> method, like a Buffer. Optionally, send a <a href="#result-class"><code>Result</code></a>
instance and the processor will take the existing [<code>Root</code>] parser from it.</li>
<li><code>opts (object) optional</code>: options:<ul>
<li><code>from</code>: the path of the CSS source file. You should always set <code>from</code>,
because it is used in source map generation and syntax error messages.</li>
<li><code>to</code>: the path where you’ll put the output CSS file. You should always set
<code>to</code> to generate correct source maps.</li>
<li><code>parser</code>: function to generate AST by string.</li>
<li><code>stringifier</code>: class to generate string by AST.</li>
<li><code>syntax</code>: object with <code>parse</code> and <code>stringify</code> functions.</li>
<li><code>map</code>: an object of <a href="https://github.com/postcss/postcss/blob/master/docs/source-maps.md">source map options</a>.</li>
</ul>
</li>
</ul>
<h3><code>processor.plugins</code></h3><p>Contains plugins added to this processor.</p>
<pre><code class="language-js">var processor = postcss([cssnext, cssgrace]);
processor.plugins.length //=&gt; 2
</code></pre>
<h3><code>processor.version</code></h3><p>Contains the current version of PostCSS.</p>
<pre><code class="language-js">postcss().version //=&gt; &#39;4.0.5&#39;
</code></pre>
<h2><code>LazyResult</code> class</h2><p>A promise proxy for the result of PostCSS transformations.</p>
<p>A <code>LazyResult</code> instance is returned by <a href="#processorprocesscss-opts"><code>Processor#process(css, opts)</code></a>.</p>
<pre><code class="language-js">var lazy = postcss([cssnext]).process(css);
</code></pre>
<h3><code>lazy.then(onFulfilled, onRejected)</code></h3><p>Processes input CSS through synchronous and asynchronous plugins
and calls <code>onFulfilled</code> with a <a href="#result-class"><code>Result</code></a> instance. If a plugin throws
an error, the <code>onRejected</code> callback will be executed.</p>
<pre><code class="language-js">postcss([cssnext]).process(css).then(function(result) {
    console.log(result.css);
});
</code></pre>
<p>This method is a standard <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">Promise</a> method.</p>
<h3><code>lazy.catch(onRejected)</code></h3><p>Processes input CSS through synchronous and asynchronous plugins
and calls <code>onRejected</code> for each error thrown in any plugin.</p>
<pre><code class="language-js">postcss([cssnext]).process(css).then(function(result) {
    console.log(result.css);
}).catch(function (error) {
    console.error(error);
});
</code></pre>
<p>This method is a standard <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">Promise</a> method.</p>
<h3><code>lazy.toString()</code></h3><p>Alias for the <code>LazyResult#css</code> property.</p>
<h3><code>lazy.css</code></h3><p>Processes input CSS through synchronous plugins, converts <code>Root</code> to a CSS
string and returns <a href="#resultcss"><code>Result#css</code></a>.</p>
<pre><code class="language-js">processor.process(css).css;
</code></pre>
<p>This property will only work with synchronous plugins. If the processor
contains any asynchronous plugins it will throw an error. In this case,
you should use <a href="#lazythenonfulfilled-onrejected"><code>LazyResult#then()</code></a> instead.</p>
<pre><code class="language-js">postcss([cssnext]).then(function (result) {
    console.log(result.css);
});
</code></pre>
<h3><code>lazy.content</code></h3><p>An alias for the <code>css</code> property. Use it with syntaxes that generate non-CSS
output.</p>
<pre><code class="language-js">lazy.css === lazy.content;
</code></pre>
<h3><code>lazy.map</code></h3><p>Processes input CSS through synchronous plugins and returns <a href="#resultmap"><code>Result#map</code></a>.</p>
<pre><code class="language-js">if ( result.map ) {
    fs.writeFileSync(result.opts.to + &#39;.map&#39;, result.map.toString());
}
</code></pre>
<p>This property will only work with synchronous plugins. If the processor
contains any asynchronous plugins it will throw an error. In this case,
you should use <a href="#lazythenonfulfilled-onrejected"><code>LazyResult#then()</code></a> instead.</p>
<pre><code class="language-js">postcss([cssnext]).then(function (result) {
    if ( result.map ) {
        fs.writeFileSync(result.opts.to + &#39;.map&#39;, result.map.toString());
    }
});
</code></pre>
<h3><code>lazy.root</code></h3><p>Processes input CSS through synchronous plugins and returns
<a href="#resultroot"><code>Result#root</code></a>.</p>
<p>This property will only work with synchronous plugins. If the processor
contains any asynchronous plugins it will throw an error. In this case,
you should use <a href="#lazythenonfulfilled-onrejected"><code>LazyResult#then()</code></a> instead.</p>
<pre><code class="language-js">postcss([cssnext]).then(function (result) {
    console.log(result.root);
});
</code></pre>
<h3><code>lazy.warnings()</code></h3><p>Processes input CSS through synchronous plugins and calls [<code>Result#warnings()</code>].</p>
<pre><code class="language-js">postcss([cssnext]).warnings().forEach(function (message) {
    console.warn(message.text);
});
</code></pre>
<p>This property will only work with synchronous plugins. If the processor
contains any asynchronous plugins it will throw an error. In this case,
you should use <a href="#lazythenonfulfilled-onrejected"><code>LazyResult#then()</code></a> instead.</p>
<pre><code class="language-js">postcss([cssnext]).then(function (result) {
    result.warnings().forEach(function (message) {
        console.warn(message.text);
    });
});
</code></pre>
<h3><code>lazy.messages</code></h3><p>Processes input CSS through synchronous plugins and returns <a href="#resultmessages"><code>Result#messages</code></a>.</p>
<p>This property will only work with synchronous plugins. If the processor
contains any asynchronous plugins it will throw an error. In this case,
you should use <a href="#lazythenonfulfilled-onrejected"><code>LazyResult#then()</code></a> instead.</p>
<h3><code>lazy.processor</code></h3><p>Returns a <a href="#processor-class"><code>Processor</code></a> instance, which will be used for CSS transformations.</p>
<pre><code class="language-js">var lazy = postcss([cssnext, cssgrace]).process(css);
lazy.processor.plugins.length //=&gt; 2
</code></pre>
<h3><code>lazy.opts</code></h3><p>Options from the <a href="#processorprocesscss-opts"><code>Processor#process(css, opts)</code></a> call that produced
this <code>Result</code> instance.</p>
<pre><code class="language-js">postcss().process(css, opts).opts == opts;
</code></pre>
<h2><code>Result</code> class</h2><p>Provides the result of the PostCSS transformations.</p>
<p>A <code>Result</code> instance is returned by <a href="#roottoresultopts"><code>Root#toResult(opts)</code></a>
or <a href="#lazythenonfulfilled-onrejected"><code>LazyResult#then()</code></a> methods.</p>
<pre><code class="language-js">postcss([cssnext]).process(css).then(function (result1) {
    console.log(result1.css);
});
var result2 = postcss.parse(css).toResult();
</code></pre>
<h3><code>result.toString()</code></h3><p>Alias for <a href="#resultcss"><code>Result#css</code></a> property.</p>
<h3><code>result.warn(text, opts)</code></h3><p>Creates an instance of <a href="#warning-class"><code>Warning</code></a> and adds it to <a href="#resultmessages"><code>Result#messages</code></a>.</p>
<pre><code class="language-js">var plugin = postcss.plugin(&#39;postcss-important&#39;, function () {
    return function (css, result) {
        css.walkDecls(function (decl) {
            if ( decl.important ) {
                result.warn(&#39;Try to avoid !important&#39;, { node: decl });
            }
        });
    };
});

postcss([plugin]).process(css).then(function (result) {
    result.warnings() //=&gt; [{
                      //      plugin: &#39;postcss-important-warning&#39;,
                      //      text:   &#39;Try to avoid !important&#39;
                      //      node:  { type: &#39;decl&#39;, … }
                      //   }]
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>text (string)</code>: warning message. It will be used in the <code>text</code> property of
the message object.</li>
<li><code>opts (object) optional</code>: properties to assign to the message object.<ul>
<li><code>node</code>: CSS node that was the source of the warning.</li>
<li><code>word (string)</code>: word inside a node’s string that should be highlighted
as the source of the warning.</li>
<li><code>index</code> (number): index inside a node’s string that should be highlighted
as the source of the warning.</li>
<li><code>plugin</code>: name of the plugin that created this warning. <code>Result#warn()</code> will
automatically fill it with the <code>plugin.postcssPlugin</code> value.</li>
</ul>
</li>
</ul>
<h3><code>result.warnings()</code></h3><p>Returns warnings from plugins. Filters <a href="#warning-class"><code>Warning</code></a> instances
from [Result#messages].</p>
<pre><code class="language-js">result.warnings().forEach(function (message) {
    console.log(message.toString());
});
</code></pre>
<h3><code>result.css</code></h3><p>A CSS string representing this <code>Result</code>’s &#39;<code>Root</code> instance.</p>
<pre><code class="language-js">postcss.parse(&#39;a{}&#39;).toResult().css //=&gt; &quot;a{}&quot;
</code></pre>
<h3><code>result.content</code></h3><p>An alias for the <code>css</code> property. Use it with syntaxes that generate non-CSS
output.</p>
<pre><code class="language-js">result.css === result.content;
</code></pre>
<h3><code>result.map</code></h3><p>An instance of the <code>SourceMapGenerator</code> class from the <a href="https://github.com/mozilla/source-map"><code>source-map</code></a> library,
representing changes to the <code>Result</code>’s <code>Root</code> instance.</p>
<pre><code class="language-js">result.map.toJSON() //=&gt; { version: 3, file: &#39;a.css&#39;, sources: [&#39;a.css&#39;], … }
</code></pre>
<p>This property will have a value <em>only if the user does not want an inline source
map</em>. By default, PostCSS generates inline source maps, written directly into
the processed CSS. The <code>map</code> property will be empty by default.</p>
<p>An external source map will be generated — and assigned to <code>map</code> —
only if the user has set the <code>map.inline</code> option to <code>false</code>, or if PostCSS
was passed an external input source map.</p>
<pre><code class="language-js">if ( result.map ) {
    fs.writeFileSync(result.opts.to + &#39;.map&#39;, result.map.toString());
}
</code></pre>
<h3><code>result.root</code></h3><p>Contains the <a href="#root-node"><code>Root</code> node</a> after all transformations.</p>
<pre><code class="language-js">root.toResult().root == root;
</code></pre>
<h3><code>result.messages</code></h3><p>Contains messages from plugins (e.g., warnings or custom messages).</p>
<p>Each message should have <code>type</code> and <code>plugin</code> properties.</p>
<pre><code class="language-js">postcss.plugin(&#39;postcss-min-browser&#39;, function () {
    return function (css, result) {
        var browsers = detectMinBrowsersByCanIUse(css);
        result.messages.push({
            type:    &#39;min-browser&#39;,
            plugin:  &#39;postcss-min-browser&#39;,
            browsers: browsers
        });
    };
});
</code></pre>
<p>Add a warning using <a href="#resultwarntext-opts"><code>Result#warn()</code></a> and get all warnings
using the <a href="#resultwarnings"><code>Result#warnings()</code></a> method.</p>
<h3><code>result.processor</code></h3><p>Returns the <a href="#processor-class"><code>Processor</code></a> instance used for this transformation.</p>
<pre><code class="language-js">result.processor.plugins.forEach(function (plugin) {
    if ( plugin.postcssPlugin == &#39;postcss-bad&#39; ) {
        throw &#39;postcss-good is incompatible with postcss-bad&#39;;
    }
});
</code></pre>
<h3><code>result.opts</code></h3><p>Options from the <a href="#processorprocesscss-opts"><code>Processor#process(css, opts)</code></a> or <a href="#roottoresultopts"><code>Root#toResult(opts)</code></a>
call that produced this <code>Result</code> instance.</p>
<pre><code class="language-js">root.toResult(opts).opts == opts;
</code></pre>
<h2><code>Warning</code> class</h2><p>Represents a plugin warning. It can be created using <a href="#nodewarnresult-message"><code>Node#warn()</code></a>.</p>
<pre><code class="language-js">if ( decl.important ) {
    decl.warn(result, &#39;Try to avoid !important&#39;);
}
</code></pre>
<h3><code>warning.toString()</code></h3><p>Returns a string with the error position and message.</p>
<pre><code class="language-js">warning.toString() //=&gt; &#39;postcss-important:a.css:10:4: Try to avoid !important&#39;
</code></pre>
<h3><code>warning.text</code></h3><p>Contains the warning message.</p>
<pre><code class="language-js">warning.text //=&gt; &#39;Try to avoid !important&#39;
</code></pre>
<h3><code>warning.plugin</code></h3><p>Contains the name of the plugin that created this warning. When you call
<a href="#nodewarnresult-message"><code>Node#warn()</code></a> it will fill this property automatically.</p>
<pre><code class="language-js">warning.plugin //=&gt; &#39;postcss-important&#39;
</code></pre>
<h3><code>warning.node</code></h3><p>Contains the CSS node that caused the warning.</p>
<pre><code class="language-js">warning.node.toString() //=&gt; &#39;color: white !important&#39;
</code></pre>
<h3><code>warning.line</code></h3><p>The line in the input file with this warning’s source.</p>
<pre><code class="language-js">warning.line //=&gt; 5
</code></pre>
<h3><code>warning.column</code></h3><p>Column in the input file with this warning’s source.</p>
<pre><code class="language-js">warning.column //=&gt; 4
</code></pre>
<h2><code>CssSyntaxError</code> class</h2><p>The CSS parser throws this error for broken CSS.</p>
<pre><code class="language-js">postcss.parse(&#39;a{&#39;) //=&gt; CssSyntaxError
</code></pre>
<p>Custom parsers can throw this error for broken custom syntax
using the <a href="#nodeerrormessage"><code>Node#error()</code></a> method.</p>
<pre><code class="language-js">throw node.error(&#39;Unknown variable&#39;, { plugin: &#39;postcss-vars&#39; });
</code></pre>
<h3><code>error.toString()</code></h3><p>Returns a string with the error position, message and source code of the
broken part.</p>
<pre><code class="language-js">error.toString() //=&gt; CssSyntaxError: app.css:1:1: Unclosed block
                 //   a {
                 //   ^
</code></pre>
<h3><code>error.showSourceCode(color)</code></h3><p>Returns a few lines of CSS source that caused the error.</p>
<pre><code class="language-js">error.showSourceCode() //=&gt;
                       //   a {
                       //     bad
                       //     ^
                       //   }
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>color (boolean) optional</code>: whether arrow will be colored red by terminal
color codes. By default, PostCSS will use <code>process.stdout.isTTY</code> and
<code>process.env.NODE_DISABLE_COLORS</code>.</li>
</ul>
<p>If the CSS has an input source map without <code>sourceContent</code>, this method will
return an empty string.</p>
<h3><code>error.message</code></h3><p>Contains full error text in the GNU error format.</p>
<pre><code class="language-js">error.message //=&gt; &#39;a.css:1:1: Unclosed block&#39;
</code></pre>
<h3><code>error.reason</code></h3><p>Contains only the error description.</p>
<pre><code class="language-js">error.reason //=&gt; &#39;Unclosed block&#39;
</code></pre>
<h3><code>error.plugin</code></h3><p>Contains the PostCSS plugin name if the error didn’t come from the CSS parser.</p>
<pre><code class="language-js">error.plugin //=&gt; &#39;postcss-vars&#39;
</code></pre>
<p>PostCSS will fill it automatically.</p>
<h3><code>error.file</code></h3><p>Contains the absolute path to the broken file. If you use it, send the <code>from</code>
option to the parser.</p>
<pre><code class="language-js">error.file //=&gt; &#39;a.sass&#39;
</code></pre>
<p>PostCSS will use the input source map to detect the original error location.
If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
PostCSS will show the original position in the Sass file.</p>
<p>If you need the position in the PostCSS input (e.g., to debug the previous
compiler), use <code>error.input.file</code>.</p>
<pre><code class="language-js">error.file       //=&gt; &#39;a.sass&#39;
error.input.file //=&gt; &#39;a.css&#39;
</code></pre>
<h3><code>error.line</code></h3><p>Contains the source line of the error.</p>
<pre><code class="language-js">error.line //=&gt; 2
</code></pre>
<p>PostCSS will use the input source map to detect the original error location.
If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
PostCSS will show the original position in the Sass file.</p>
<p>If you need the position in the PostCSS input (e.g., to debug the previous
compiler), use <code>error.input.file</code>.</p>
<pre><code class="language-js">error.line       //=&gt; 2
error.input.line //=&gt; 4
</code></pre>
<h3><code>error.column</code></h3><p>Contains the source column of the error.</p>
<pre><code class="language-js">error.column //=&gt; 1
</code></pre>
<p>PostCSS will use the input source map to detect the original error location.
If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
PostCSS will show the original position in the Sass file.</p>
<p>If you need the position in the PostCSS input (e.g., to debug the previous
compiler), use <code>error.input.file</code>.</p>
<pre><code class="language-js">error.column       //=&gt; 1
error.input.column //=&gt; 4
</code></pre>
<h3><code>error.source</code></h3><p>Contains the source code of the broken file.</p>
<pre><code class="language-js">error.source //=&gt; &#39;a {} b {&#39;
</code></pre>
<p>PostCSS will use the input source map to detect the original error location.
If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
PostCSS will show the original position in the Sass file.</p>
<p>If you need the position in the PostCSS input (e.g., to debug the previous
compiler), use <code>error.input.file</code>.</p>
<pre><code class="language-js">error.source       //=&gt; &#39;a { b {} }&#39;
error.input.column //=&gt; &#39;a b { }&#39;
</code></pre>
<h2>Vendor module</h2><p>Contains helpers for working with vendor prefixes.</p>
<pre><code class="language-js">var vendor = postcss.vendor;
</code></pre>
<h3><code>vendor.prefix(string)</code></h3><p>Returns the vendor prefix extracted from an input string.</p>
<pre><code class="language-js">postcss.vendor.prefix(&#39;-moz-tab-size&#39;) //=&gt; &#39;-moz-&#39;
</code></pre>
<h3><code>vendor.unprefixed(string)</code></h3><p>Returns the input string stripped of its vendor prefix.</p>
<pre><code class="language-js">postcss.vendor.unprefixed(&#39;-moz-tab-size&#39;) //=&gt; &#39;tab-size&#39;
</code></pre>
<h2>List module</h2><p>Contains helpers for safely splitting lists of CSS values,
preserving parentheses and quotes.</p>
<pre><code class="language-js">var list = postcss.list;
</code></pre>
<h3><code>list.space(string)</code></h3><p>Safely splits space-separated values (such as those for <code>background</code>,
<code>border-radius</code>, and other shorthand properties).</p>
<pre><code class="language-js">postcss.list.space(&#39;1px calc(10% + 1px)&#39;) //=&gt; [&#39;1px&#39;, &#39;calc(10% + 1px)&#39;]
</code></pre>
<h3><code>list.comma(string)</code></h3><p>Safely splits comma-separated values (such as those
for <code>transition-*</code> and <code>background</code> properties).</p>
<pre><code class="language-js">postcss.list.comma(&#39;black, linear-gradient(white, black)&#39;)
//=&gt; [&#39;black&#39;, &#39;linear-gradient(white, black)&#39;]
</code></pre>
<h2><code>Input</code> class</h2><p>Represents the source CSS.</p>
<pre><code class="language-js">var root  = postcss.parse(css, { from: file });
var input = root.source.input;
</code></pre>
<h3><code>input.file</code></h3><p>The absolute path to the CSS source file defined with the <a href="#processorprocesscss-opts"><code>from</code> option</a>.</p>
<pre><code class="language-js">var root  = postcss.parse(css, { from: &#39;a.css&#39; });
root.source.input.file //=&gt; &#39;/home/ai/a.css&#39;
</code></pre>
<h3><code>input.id</code></h3><p>The unique ID of the CSS source. Used if <code>from</code>
option is not provided (because PostCSS does not know the file path).</p>
<pre><code class="language-js">var root  = postcss.parse(css);
root.source.input.file //=&gt; undefined
root.source.input.id   //=&gt; &lt;input css 1&gt;
</code></pre>
<h3><code>input.from</code></h3><p>The CSS source identifier. Contains <a href="#inputfile"><code>input.file</code></a> if the user set
the <a href="#processorprocesscss-opts"><code>from</code> option</a>, or <a href="#inputid"><code>input.id</code></a> if they did not.</p>
<pre><code class="language-js">var root  = postcss.parse(css, { from: &#39;a.css&#39; });
root.source.input.from //=&gt; &#39;/home/ai/a.css&#39;

var root  = postcss.parse(css);
root.source.input.from //=&gt; &lt;input css 1&gt;
</code></pre>
<h3><code>input.map</code></h3><p>Represents the input source map passed from a compilation step before PostCSS
(e.g., from the Sass compiler).</p>
<p><code>map.consumer()</code> returns an instance of the <code>SourceMapConsumer</code> class
from the <a href="https://github.com/mozilla/source-map"><code>source-map</code></a> library.</p>
<pre><code class="language-js">root.source.input.map.consumer().sources //=&gt; [&#39;a.sass&#39;]
</code></pre>
<h3><code>input.origin(line, column)</code></h3><p>Reads the input source map and returns a symbol position in the input source
(e.g., in a Sass file that was compiled to CSS before being passed
to PostCSS):</p>
<pre><code class="language-js">root.source.input.origin(1, 1) //=&gt; { file: &#39;a.css&#39;, line: 3, column: 1 }
</code></pre>
<h2>Nodes: common methods</h2><p>All node classes inherit the following common methods.</p>
<h3><code>node.type</code></h3><p>Returns a string representing the node’s type.</p>
<p>Possible values are <code>root</code>, <code>atrule</code>, <code>rule</code>, <code>decl</code>, or <code>comment</code>.</p>
<pre><code class="language-js">postcss.decl({ prop: &#39;color&#39;, value: &#39;black&#39; }).type //=&gt; &#39;decl&#39;
</code></pre>
<h3><code>node.parent</code></h3><p>Returns the node’s parent node.</p>
<pre><code class="language-js">root.nodes[0].parent == root;
</code></pre>
<h3><code>node.source</code></h3><p>Returns the input source of the node, with the following properties:</p>
<ul>
<li><code>node.source.input</code>: An <a href="#inputclass"><code>Input</code></a> instance.</li>
<li><code>node.source.start</code>: The starting position of the node’s source —
line and column.</li>
<li><code>node.source.end</code>: The ending position of the node’s source — line and column.</li>
</ul>
<pre><code class="language-js">decl.source.input.from //=&gt; &#39;/home/ai/a.sass&#39;
decl.source.start      //=&gt; { line: 10, column: 2 }
decl.source.end        //=&gt; { line: 10, column: 12 }
</code></pre>
<p>The property is used in source map generation.</p>
<p>If you create a node manually (e.g., with <code>postcss.decl()</code>),
that node will not have a <code>source</code> property and will be absent
from the source map. For this reason, the plugin developer should consider
cloning nodes to create new ones (in which case the new node’s source
will reference the original, cloned node) or setting the <code>source</code> property
manually.</p>
<pre><code class="language-js">// Bad
var prefixed = postcss.decl({ prop: &#39;-moz-&#39; + decl.prop, value: decl.value });

// Good
var prefixed = decl.clone({ prop: &#39;-moz-&#39; + decl.prop });
</code></pre>
<pre><code class="language-js">if ( atrule.name == &#39;add-link&#39; ) {
    var rule = postcss.rule({ selector: &#39;a&#39; }); // Rule has no source
    atrule.parent.insertBefore(atrule, rule);   // We add it because of atrule
    rule.source = atrule.source;                // So we copy source from atrule
}
</code></pre>
<h3><code>node.raws</code></h3><p>Contains information to generate byte-to-byte equal node string
as it was in the origin input.</p>
<p>Every parser saves its own properties, but the default CSS parser uses:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code> and <code>_</code>
symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node to the end of the
node.</li>
<li><code>between</code>: the symbols between the property and value for declarations,
selector and <code>{</code> for rules, or last parameter and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains <code>true</code> if the last child has an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule’s name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text and <code>*/</code>.</li>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS cleans selectors, declaration values and at-rule parameters
from comments and extra spaces, but it stores origin content
in <code>raws</code> properties. As such, if you don’t change a declaration’s value,
PostCSS will use the raw value with comments.</p>
<h3><code>node.toString()</code></h3><p>Returns a CSS string representing the node.</p>
<pre><code class="language-js">postcss.rule({ selector: &#39;a&#39; }).toString() //=&gt; &#39;a {}&#39;&#39;
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>stringifier (functions|object) optional</code>: a syntax to use
in string generation.</li>
</ul>
<h3><code>node.error(message, opts)</code></h3><p>Returns a <a href="#csssyntaxerror-class"><code>CssSyntaxError</code></a> instance containing the original position
of the node in the source, showing line and column numbers and also
a small excerpt to facilitate debugging.</p>
<p>If present, an input source map will be used to get the original position
of the source, even from a previous compilation step
(e.g., from Sass compilation).</p>
<p>This method produces very useful error messages.</p>
<pre><code class="language-js">if ( !variables[name] ) {
    throw decl.error(&#39;Unknown variable &#39; + name, { word: name });
    // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
    // a
    //   color: $black
    //          ^
    //   background: white
}
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>message (string)</code>: error description.</li>
<li><code>opts (object) optional</code>: options.<ul>
<li><code>plugin (string)</code>: plugin name that created this error.
PostCSS will set it automatically.</li>
<li><code>word (string)</code>: a word inside a node’s string that should be highlighted
as the source of the error.</li>
<li><code>index</code> (number): an index inside a node’s string that should be highlighted
as the source of the error.</li>
</ul>
</li>
</ul>
<h3><code>node.warn(result, text, opts)</code></h3><p>This method is provided as a convenience wrapper for <a href="#resultwarntext-opts"><code>Result#warn()</code></a>.</p>
<pre><code class="language-js">var plugin = postcss.plugin(&#39;postcss-deprecated&#39;, function () {
    return function (css, result) {
        css.walkDecls(&#39;bad&#39;, function (decl) {
            decl.warn(result, &#39;Deprecated property bad&#39;);
        });
    };
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>result</code>: The <a href="#result-class"><code>Result</code></a> instance that will receive the warning.</li>
<li><code>text (string)</code>: warning message. It will be used in the <code>text</code> property of
the message object.</li>
<li><code>opts (object) optional</code>: properties to assign to the message object.<ul>
<li><code>word (string)</code>: word inside a node’s string that should be highlighted
as the source of the warning.</li>
<li><code>index</code> (number): index inside a node’s string that should be highlighted
as the source of the warning.</li>
<li><code>plugin</code>: name of the plugin that created this warning. <code>Result#warn()</code> will
automatically fill it with the <code>plugin.postcssPlugin</code> value.</li>
</ul>
</li>
</ul>
<p>Note that <code>opts.node</code> is automatically passed to <a href="#resultwarntext-opts"><code>Result#warn()</code></a> for you.</p>
<h3><code>node.next()</code> and <code>node.prev()</code></h3><p>Returns the next/previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the last/first child.</p>
<pre><code class="language-js">var annotation = decl.prev();
if ( annotation.type == &#39;comment&#39; ) {
    readAnnotation( annotation.text );
}
</code></pre>
<h3><code>node.root()</code></h3><p>Returns the <code>Root</code> instance of the node’s tree.</p>
<pre><code class="language-js">root.nodes[0].nodes[0].root() == root
</code></pre>
<h3><code>node.remove()</code></h3><p>Removes the node from its parent and cleans the <code>parent</code> properties from the
node and its children.</p>
<pre><code class="language-js">if ( decl.prop.match(/^-webkit-/) ) {
    decl.remove();
}
</code></pre>
<h3><code>node.replaceWith(...otherNodes)</code></h3><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="language-js">if ( atrule.name == &#39;mixin&#39; ) {
    atrule.replaceWith(mixinRules[atrule.params]);
}
</code></pre>
<h3><code>node.clone(props)</code></h3><p>Returns a clone of the node.</p>
<p>The resulting cloned node and its (cloned) children will have a clean <code>parent</code>
and code style properties.</p>
<pre><code class="language-js">var cloned = decl.clone({ prop: &#39;-moz-&#39; + decl.prop });
cloned.raws.before  //=&gt; undefined
cloned.parent       //=&gt; undefined
cloned.toString()   //=&gt; -moz-transform: scale(0)
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object) optional</code>: new properties to override in the clone.</li>
</ul>
<h3><code>node.cloneBefore(props)</code> and <code>node.cloneAfter(props)</code></h3><p>Shortcut to clone the node and insert the resulting cloned node before/after
the current node.</p>
<pre><code class="language-js">decl.cloneBefore({ prop: &#39;-moz-&#39; + decl.prop });
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object) optional</code>: new properties to override in the clone.</li>
</ul>
<h3><code>node.moveTo(newParent)</code></h3><p>Removes the node from its current parent and inserts it
at the end of <code>newParent</code>.</p>
<p>This will clean the <code>before</code> and <code>after</code> code style properties from the node
and replace them with the indentation style of <code>newParent</code>. It will also clean
the <code>between</code> property if <code>newParent</code> is in another <code>Root</code>.</p>
<pre><code class="language-js">atrule.moveTo(atrule.parent.parent);
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>newParent: (Container)</code>: container node where the current node will be moved.</li>
</ul>
<h3><code>node.moveBefore(otherNode)</code> and <code>node.moveAfter(otherNode)</code></h3><p>Removes the node from its current parent and inserts it into a new parent
before/after <code>otherNode</code>.</p>
<p>This will also clean the node’s code style properties just as it would in
<code>node.moveTo(newParent)</code>.</p>
<p>Arguments:</p>
<ul>
<li><code>otherNode (Node)</code>: node that will be after/before current node after moving.</li>
</ul>
<h3><code>node.raw(prop, defaultType)</code></h3><p>Returns a code style property value. If the node is missing the code style
property (because the node was manually built or cloned), PostCSS will try
to autodetect the code style property by looking at other nodes in the tree.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a { background: white }&#39;);
root.nodes[0].append({ prop: &#39;color&#39;, value: &#39;black&#39; });
root.nodes[0].nodes[1].raws.before //=&gt; &#39; &#39;
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>prop (string)</code>: name or code style property.</li>
<li><code>defaultType (string)</code>: name of default value. It can be easily missed
if the value is the same as <code>prop</code>.</li>
</ul>
<h2>Containers: common methods</h2><p>The <code>Root</code>, <code>AtRule</code>, and <code>Rule</code> container nodes inherit some common methods
to help work with their children.</p>
<p>Note that all containers can store <em>any</em> content. If you write a rule inside
a rule, PostCSS will parse it.</p>
<h3><code>container.nodes</code></h3><p>An array containing the container’s children.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a { color: black }&#39;);
root.nodes.length           //=&gt; 1
root.nodes[0].selector      //=&gt; &#39;a&#39;
root.nodes[0].nodes[0].prop //=&gt; &#39;color&#39;
</code></pre>
<h3><code>container.first</code></h3><p>The container’s first child.</p>
<pre><code class="language-js">rule.first == rules.nodes[0];
</code></pre>
<h3><code>container.last</code></h3><p>The container’s last child.</p>
<pre><code class="language-js">rule.last == rule.nodes[rule.nodes.length - 1];
</code></pre>
<h3><code>container.index(child)</code></h3><p>Returns a <code>child</code>’s index within the container’s <code>nodes</code> array.</p>
<pre><code class="language-js">rule.index( rule.nodes[2] ) //=&gt; 2
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>child (Node)</code>: child of the current container.</li>
</ul>
<h3><code>container.every(callback)</code></h3><p>Returns <code>true</code> if <code>callback</code> returns true for all of the container’s children.</p>
<pre><code class="language-js">var noPrefixes = rule.every(function (decl) {
    return decl.prop[0] != &#39;-&#39;;
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: iterator. Returns true or false.</li>
</ul>
<h3><code>container.some(callback)</code></h3><p>Returns <code>true</code> if <code>callback</code> returns true for (at least) one
of the container’s children.</p>
<pre><code class="language-js">var hasPrefix = rule.some(function (decl) {
    return decl.prop[0] == &#39;-&#39;;
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: iterator. Returns true or false.</li>
</ul>
<h3><code>container.each(callback)</code></h3><p>Iterates through the container’s immediate children, calling <code>callback</code>
for each child.</p>
<p>Returning <code>false</code> in the <code>callback</code> will break iteration.</p>
<pre><code class="language-js">var color;
rule.each(function (decl) {
    if ( decl.prop == &#39;color&#39; ) {
        color = decl.value;
        return false;
    }
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: iterator. Receives each node and its index.</li>
</ul>
<p>Unlike the <code>for {}</code>-cycle or <code>Array#forEach()</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a { color: black; z-index: 1 }&#39;);
var rule = root.first;

for ( var i = 0; i &lt; rule.nodes.length; i++ ) {
    var decl = rule.nodes[i];
    decl.cloneBefore({ prop: &#39;-webkit-&#39; + decl.prop });
    // Cycle will be infinite, because cloneBefore moves the current node
    // to the next index
}

rule.each(function (decl) {
    decl.cloneBefore({ prop: &#39;-webkit-&#39; + decl.prop });
    // Will be executed only for color and z-index
});
</code></pre>
<p><code>container.each()</code> only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant nodes,
use <code>container.walk()</code>.</p>
<h3><code>container.walk(callback)</code></h3><p>Traverses the container’s descendant nodes, calling <code>callback</code> for each node.</p>
<pre><code class="language-js">root.walk(function (node) {
    // Traverses all descendant nodes.
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: iterator. Receives each node and its index.</li>
</ul>
<p>Like <code>container.each()</code>, this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code>container.each()</code>.</p>
<h3><code>container.walkDecls([propFilter,] callback)</code></h3><p>Traverses the container’s descendant nodes, calling <code>callback</code> for each
declaration node.</p>
<pre><code class="language-js">root.walkDecls(function (decl) {
    if ( decl.prop.match(/^-webkit-/) ) {
        decl.remove();
    }
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>propFilter: (string|RegExp) optional</code>: string or regular expression
to filter declarations by property name.<ul>
<li><code>callback (function)</code>: iterator. Receives each declaration node and its
index.</li>
</ul>
</li>
</ul>
<p>If you pass a <code>propFilter</code>, iteration will only happen over declarations with
matching properties.</p>
<pre><code class="language-js">// Make a flat design
root.walkDecls(&#39;border-radius&#39;, function (decl) {
    decl.remove();
});
root.walkDecls(/^background/, function (decl) {
    decl.value = takeFirstColorFromGradient(decl.value);
});
</code></pre>
<p>Like <code>container.each()</code>, this method is safe to use if you are mutating
arrays during iteration.</p>
<h3><code>container.walkAtRules([nameFilter,] callback)</code></h3><p>Traverses the container’s descendant nodes, calling <code>callback</code> for each
at-rule node.</p>
<pre><code class="language-js">root.walkAtRules(function (rule) {
    if ( rule.name.match(/^-webkit-/) ) rule.remove();
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>nameFilter: (string|RegExp) optional</code>: string or regular expression to filter
at-rules by name.<ul>
<li><code>callback (function)</code>: iterator. Receives each at-rule and its index.</li>
</ul>
</li>
</ul>
<p>If you pass a <code>filter</code>, iteration will only happen over at-rules that have
matching names.</p>
<pre><code class="language-js">var first = false;
root.walkAtRules(&#39;charset&#39;, function (rule) {
    if ( !first ) {
        first = true;
    } else {
        rule.remove();
    }
});
</code></pre>
<p>Like <code>container.each()</code>, this method is safe to use if you are mutating arrays
during iteration.</p>
<h3><code>container.walkRules([selectorFilter,] callback)</code></h3><p>Traverses the container’s descendant nodes, calling <code>callback</code> for each
rule node.</p>
<pre><code class="language-js">var selectors = [];
root.walkRules(function (rule) {
    selectors.push(rule.selector);
});
console.log(&#39;Your CSS uses &#39; + selectors.length + &#39; selectors&#39;);
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>selectorFilter: (string|RegExp) optional</code>: string or regular expression
to filter rules by selector.</li>
<li><code>callback (function)</code>: iterator. Receives each rule node and its index.</li>
</ul>
<p>If you pass a <code>selectorFilter</code>, iteration will only happen over rules with
matching selectors.</p>
<p>Like <code>container.each()</code>, this method is safe to use if you are mutating arrays
during iteration.</p>
<h3><code>container.walkComments(callback)</code></h3><p>Traverses the container’s descendant nodes, calling <code>callback</code> for each
comment node.</p>
<pre><code class="language-js">root.walkComments(function (comment) {
    comment.remove();
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: iterator. Receives each comment node and its index.</li>
</ul>
<p>Like <code>container.each()</code>, this method is safe to use if you are mutating arrays
during iteration.</p>
<h3><code>container.replaceValues(pattern, opts, callback)</code></h3><p>Passes all declaration values within the container that match <code>pattern</code> through
<code>callback</code>, replacing those values with the returned result of <code>callback</code>.</p>
<p>This method is useful if you are using a custom unit or function and need
to iterate through all values.</p>
<pre><code class="language-js">root.replaceValues(/\d+rem/, { fast: &#39;rem&#39; }, function (string) {
    return 15 * parseInt(string) + &#39;px&#39;;
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>pattern (string|RegExp)</code>: replace pattern.</li>
<li><code>opts (object) optional</code>: options to speed up the search:<ul>
<li><code>props</code>: An array of property names. The method will only search for values
that match <code>regexp</code> within declarations of listed properties.</li>
<li><code>fast</code>: A string that’s used to narrow down values and speed up
the regexp search. Searching every single value with a regexp can be slow.
If you pass a <code>fast</code> string, PostCSS will first check whether the value
contains the <code>fast</code> string; and only if it does will PostCSS check that
value against <code>regexp</code>. For example, instead of just checking for <code>/\d+rem/</code>
on all values, set <code>fast: &#39;rem&#39;</code> to first check whether a value has
the <code>rem</code> unit, and only if it does perform the regexp check.</li>
</ul>
</li>
<li><code>callback (function|string)</code>: string to replace <code>pattern</code> or callback that
returns a new value. The callback will receive the same arguments as those
passed to a function parameter of <a href="(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter)"><code>String#replace</code></a>.</li>
</ul>
<h3><code>container.prepend(...nodes)</code> and <code>container.append(...nodes)</code></h3><p>Inserts new nodes to the start/end of the container.</p>
<pre><code class="language-js">var decl = postcss.decl({ prop: &#39;color&#39;, value: &#39;black&#39; });
rule.append(decl);
</code></pre>
<pre><code class="language-js">var decl1 = postcss.decl({ prop: &#39;color&#39;, value: &#39;black&#39; });
var decl2 = postcss.decl({ prop: &#39;background-color&#39;, value: &#39;white&#39; });
rule.prepend(decl1, decl2);
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>node (Node|array|object|string)</code>: new node.</li>
</ul>
<p>Because each node class is identifiable by unique properties, use
the following shortcuts to create nodes in insert methods:</p>
<pre><code class="language-js">root.append({ name: &#39;charset&#39;, params: &#39;&quot;UTF-8&quot;&#39; }); // at-rule
root.append({ selector: &#39;a&#39; });                       // rule
rule.append({ prop: &#39;color&#39;, value: &#39;black&#39; });       // declaration
rule.append({ text: &#39;Comment&#39; })                      // comment
</code></pre>
<p>A string containing the CSS of the new element can also be used.
This approach is slower than the above shortcuts.</p>
<pre><code class="language-js">root.append(&#39;a {}&#39;);
root.first.append(&#39;color: black; z-index: 1&#39;);
</code></pre>
<h3><code>container.insertBefore(oldNode, newNode)</code> and <code>container.insertAfter(oldNode, newNode)</code></h3><p>Insert <code>newNode</code> before/after <code>oldNode</code> within the container.</p>
<pre><code class="language-js">rule.insertBefore(decl, decl.clone({ prop: &#39;-webkit-&#39; + decl.prop }));
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>oldNode (Node|number)</code>: child or child’s index.</li>
<li><code>node (Node|array|object|string)</code>: new node.</li>
</ul>
<h3><code>container.removeChild(node)</code></h3><p>Removes <code>node</code> from the container and cleans the <code>parent</code> properties from the
node and its children.</p>
<pre><code class="language-js">rule.nodes.length  //=&gt; 5
rule.removeChild(decl);
rule.nodes.length  //=&gt; 4
decl.parent        //=&gt; undefined
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>node (Node|number)</code>: child or child’s index.</li>
</ul>
<h3><code>container.removeAll()</code></h3><p>Removes all children from the container and cleans their <code>parent</code> properties.</p>
<pre><code class="language-js">rule.removeAll();
rule.nodes.length //=&gt; 0
</code></pre>
<h2><code>Root</code> node</h2><p>Represents a CSS file and contains all its parsed nodes.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a{color:black} b{z-index:2}&#39;);
root.type         //=&gt; &#39;root&#39;
root.nodes.length //=&gt; 2
</code></pre>
<h3><code>root.toResult(opts)</code></h3><p>Returns a <a href="#result-class"><code>Result</code></a> instance representing the root’s CSS.</p>
<pre><code class="language-js">var root1 = postcss.parse(css1, { from: &#39;a.css&#39; });
var root2 = postcss.parse(css2, { from: &#39;b.css&#39; });

root1.append(root2);
var result = root1.toResult({ to: &#39;all.css&#39;, map: true });
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>opts (object) optional</code>: options:<ul>
<li><code>to</code>: the path where you’ll put the output CSS file. You should always set
<code>to</code> to generate correct source maps.</li>
<li><code>map</code>: an object of <a href="https://github.com/postcss/postcss/blob/master/docs/source-maps.md">source map options</a>.</li>
</ul>
</li>
</ul>
<h2><code>AtRule</code> node</h2><p>Represents an at-rule.</p>
<p>If it’s followed in the CSS by a <code>{}</code> block, this node will have a <code>nodes</code>
property representing its children.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;@charset &quot;UTF-8&quot;; @media print {}&#39;);

var charset = root.first;
charset.type  //=&gt; &#39;atrule&#39;
charset.nodes //=&gt; undefined

var media = root.last;
media.nodes   //=&gt; []
</code></pre>
<h3><code>atrule.name</code></h3><p>The at-rule’s name. This is the identifier that immediately follows the <code>@</code>.</p>
<pre><code class="language-js">var root  = postcss.parse(&#39;@media print {}&#39;);
var media = root.first;
media.name //=&gt; &#39;media&#39;
</code></pre>
<h3><code>atrule.params</code></h3><p>The at-rule’s parameters. These are the values that follow the at-rule’s name
but precede any <code>{}</code> block. The spec refers to this area
as the at-rule’s “prelude”.</p>
<pre><code class="language-js">var root  = postcss.parse(&#39;@media print, screen {}&#39;);
var media = root.first;
media.params //=&gt; &#39;print, screen&#39;
</code></pre>
<h2><code>Rule</code> node</h2><p>Represents a CSS rule: a selector followed by a declaration block.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a{}&#39;);
var rule = root.first;
rule.type       //=&gt; &#39;rule&#39;
rule.toString() //=&gt; &#39;a{}&#39;
</code></pre>
<h3><code>rule.selector</code></h3><p>The rule’s full selector represented as a string. If there are multiple
comma-separated selectors, the entire group will be included.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a, b { }&#39;);
var rule = root.first;
rule.selector //=&gt; &#39;a, b&#39;
</code></pre>
<h3><code>rule.selectors</code></h3><p>An array containing the rule’s individual selectors.
Groups of selectors are split at commas.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a, b { }&#39;);
var rule = root.first;

rule.selector  //=&gt; &#39;a, b&#39;
rule.selectors //=&gt; [&#39;a&#39;, &#39;b&#39;]

rule.selectors = [&#39;a&#39;, &#39;strong&#39;];
rule.selector //=&gt; &#39;a, strong&#39;
</code></pre>
<h2><code>Declaration</code> node</h2><p>Represents a CSS declaration.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a { color: black }&#39;);
var decl = root.first.first;
decl.type       //=&gt; &#39;decl&#39;
decl.toString() //=&gt; &#39; color: black&#39;
</code></pre>
<h3><code>declaration.prop</code></h3><p>The declaration’s property name.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a { color: black }&#39;);
var decl = root.first.first;
decl.prop //=&gt; &#39;color&#39;
</code></pre>
<h3><code>declaration.value</code></h3><p>The declaration’s value.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a { color: black }&#39;);
var decl = root.first.first;
decl.value //=&gt; &#39;black&#39;
</code></pre>
<h3><code>declaration.important</code></h3><p><code>true</code> if the declaration has an <code>!important</code> annotation.</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a { color: black !important; color: white }&#39;);
root.first.first.important //=&gt; true
root.first.last.important  //=&gt; undefined
</code></pre>
<h2><code>Comment</code> node</h2><p>Represents a comment between declarations or statements (rule and at-rules).
Comments inside selectors, at-rule parameters, or declaration values
will be stored in the <a href="#noderaws"><code>Node#raws</code></a> properties explained above.</p>
<pre><code class="language-js">var root    = postcss.parse(&#39;a { color: /* inner */ black; /* outer */ }&#39;);
var decl    = root.first.first;
var comment = root.first.last;

comment.type //=&gt; &#39;comment&#39;
decl.between //=&gt; &#39;: /* inner */&#39;
</code></pre>
<h3><code>comment.text</code></h3><p>The comment’s text.</p>
<pre><code class="language-js">var root    = postcss.parse(&#39;/* Empty file */&#39;);
var comment = root.first;
var comment.text //=&gt; &#39;Empty file&#39;
</code></pre>

	 <!-- Bootstrap core JavaScript
 ================================================== -->
 <!-- Placed at the end of the document so the pages load faster -->
     <script src="js/jquery.js"></script>
    <script src="js/tether.js"></script>
    <script src="js/bootstrap.js"></script>

</body>
</html>