<h1>tiny-lr <a href="https://travis-ci.org/mklabs/tiny-lr"><img src="https://travis-ci.org/mklabs/tiny-lr.svg?branch=master" alt="Build Status"></a></h1><p>This script manages a tiny <a href="http://livereload.com/">LiveReload</a> server
implementation.</p>
<p><a href="https://nodei.co/npm/tiny-lr/"><img src="https://nodei.co/npm/tiny-lr.png?downloads=true&amp;stars=true" alt="NPM"></a></p>
<p>It exposes an HTTP server and express middleware, with a very basic REST
Api to notify the server of a particular change.</p>
<p>It doesn&#39;t have any watch ability, it must be done at the build process or
application level.</p>
<p>Instead, it exposes a very simple API to notify the server that some
changes have been made, then broadcasted to every livereload client
connected.</p>
<pre><code># notify a single change
curl http://localhost:35729/changed?files=style.css

# notify using a longer path
curl http://localhost:35729/changed?files=js/app.js

# notify multiple changes, comma or space delimited
curl http://localhost:35729/changed?files=index.html,style.css,docs/docco.css
</code></pre><p>Or you can bulk the information into a POST request, with body as a JSON array of files.</p>
<pre><code>curl -X POST http://localhost:35729/changed -d &#39;{ &quot;files&quot;: [&quot;style.css&quot;, &quot;app.js&quot;] }&#39;

# from a JSON file
node -pe &#39;JSON.stringify({ files: [&quot;some.css&quot;, &quot;files.css&quot;] })&#39; &gt; files.json
curl -X POST -d @files.json http://localhost:35729
</code></pre><p>As for the livereload client, you need to install the browser extension:
<a href="http://feedback.livereload.com/knowledgebase/articles/86242-how-do-i-install-and-use-the-browser-extensions-">http://feedback.livereload.com/knowledgebase/articles/86242-how-do-i-install-and-use-the-browser-extensions-</a>
(<strong>note</strong>: you need to listen on port 35729 to be able to use with your
brower extension)</p>
<p>or add the livereload script tag manually:
<a href="http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-">http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-</a>
(and here you can choose whatever port you want)</p>
<h2>Integration</h2><p>The best way to integrate the runner in your workflow is to add it as a <code>reload</code>
step within your build tool.</p>
<pre><code class="language-js">var tinylr = require(&#39;tiny-lr&#39;);

// standard LiveReload port
var port = 35729;

// tinylr(opts) =&gt; new tinylr.Server(opts);
tinylr().listen(port, function() {
  console.log(&#39;... Listening on %s ...&#39;, port);
})
</code></pre>
<p>You can define your own route and listen for specific request:</p>
<pre><code class="language-js">var server = tinylr();

server.on(&#39;GET /myplace&#39;, function(req, res) {
  res.write(&#39;Mine&#39;);
  res.end();
})
</code></pre>
<p>And stop the server manually:</p>
<pre><code class="language-js">server.close();
</code></pre>
<p>This will close any websocket connection established and emit a close event.</p>
<h3>Middleware</h3><p>To use as a connect / express middleware, tiny-lr needs query /
bodyParser middlewares prior in the stack (to handle POST requests)</p>
<p>Any handled requests ends at the tinylr level, not found and errors are
nexted to the rest of the stack.</p>
<pre><code class="language-js">var port = process.env.LR_PORT || process.env.PORT || 35729;

var path    = require(&#39;path&#39;);
var express = require(&#39;express&#39;);
var tinylr  = require(&#39;tiny-lr&#39;);
var body    = require(&#39;body-parser&#39;);

var app = express();

// This binds both express app and tinylr on the same port


app
  .use(body())
  .use(tinylr.middleware({ app: app }))
  .use(express.static(path.resolve(&#39;./&#39;)))
  .listen(port, function() {
    console.log(&#39;listening on %d&#39;, port);
  });
</code></pre>
<p>The port you listen on is important, and tinylr should <strong>always</strong> listen on
the LiveReload standard one: <code>35729</code>. Otherwise, you won&#39;t be able to rely
on the browser extensions, though you can still use the manual snippet
approach.</p>
<p>You can also start two different servers, one on your app port, the
other listening on the LiveReload port.</p>
<h3>Using grunt</h3><p>Head over to <a href="https://github.com/gruntjs/grunt-contrib-watch#live-reloading">https://github.com/gruntjs/grunt-contrib-watch</a></p>
<h3>Using make</h3><p>See <a href="https://github.com/mklabs/make-livereload">make-livereload</a> repo.
This repository defines a bin wrapper you can use and install with:</p>
<pre><code>npm install make-livereload -g
</code></pre><p>It bundles the same bin wrapper previously used in tiny-lr repo.</p>
<pre><code>Usage: tiny-lr [options]

Options:

  -h, --help     output usage information
  -V, --version  output the version number
  port           -p
  pid            Path to the generated PID file (default: ./tiny-lr.pid)
</code></pre><h3>Using gulp</h3><p>See <a href="https://github.com/vohof/gulp-livereload">gulp-livereload</a> repo.</p>
<h2>Options</h2><ul>
<li><code>livereload</code>    - Path to the client side lib (defaults to <code>path.join(__dirname, &#39;../node_modules/livereload-js/dist/livereload.js&#39;)</code>)</li>
<li><code>port</code>          - Livereload port (defaults to <code>35729</code>)</li>
<li><code>errorListener</code> - A callback to invoke when an error occurs (otherwise, fallbacks to standard error output)</li>
<li><code>app</code>           - An express or other middleware based HTTP server</li>
<li><code>key</code>           - Option to pass in to create an https server</li>
<li><code>cert</code>          - Option to pass in to create an https server</li>
<li><code>pfx</code>           - Can also be used to create an https server instead of <code>key</code> &amp; <code>cert</code></li>
<li><code>liveCSS</code>       - LiveReload option to enable live CSS reloading (defaults to true)</li>
<li><code>liveJs</code>        - LiveReload option to enable live JS reloading (defaults to true)</li>
<li><code>liveImg</code>       - LiveReload option to enable live images reloading (defaults to true)</li>
</ul>
<h2>Tests</h2><pre><code>npm test
</code></pre><hr>
<h1>TOC</h1><ul>
<li><a href="#tiny-lr">tiny-lr</a><ul>
<li><a href="#tiny-lr-get-">GET /</a></li>
<li><a href="#tiny-lr-get-changed">GET /changed</a></li>
<li><a href="#tiny-lr-post-changed">POST /changed</a></li>
<li><a href="#tiny-lr-get-livereloadjs">GET /livereload.js</a></li>
<li><a href="#tiny-lr-get-kill">GET /kill</a>
<a name="" /></li>
</ul>
</li>
</ul>
<p><a name="tiny-lr" /></p>
<h1>tiny-lr</h1><p>accepts ws clients.</p>
<pre><code class="language-js">var url = parse(this.request.url);
var server = this.app;

var ws = this.ws = new WebSocket(&#39;ws://&#39; + url.host + &#39;/livereload&#39;);

ws.onopen = function(event) {
  var hello = {
    command: &#39;hello&#39;,
    protocols: [&#39;http://livereload.com/protocols/official-7&#39;]
  };

  ws.send(JSON.stringify(hello));
};

ws.onmessage = function(event) {
  assert.deepEqual(event.data, JSON.stringify({
    command: &#39;hello&#39;,
    protocols: [&#39;http://livereload.com/protocols/official-7&#39;],
    serverName: &#39;tiny-lr&#39;
  }));

  assert.ok(Object.keys(server.clients).length);
  done();
};
</code></pre>
<p>properly cleans up established connection on exit.</p>
<pre><code class="language-js">var ws = this.ws;

ws.onclose = done.bind(null, null);

request(this.server)
  .get(&#39;/kill&#39;)
  .expect(200, function() {
    console.log(&#39;server shutdown&#39;);
  });
</code></pre>
<p><a name="tiny-lr" /></p>
<h1>tiny-lr</h1><p><a name="tiny-lr-get-" /></p>
<h2>GET /</h2><p>respond with nothing, but respond.</p>
<pre><code class="language-js">request(this.server)
  .get(&#39;/&#39;)
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(&#39;{&quot;tinylr&quot;:&quot;Welcome&quot;,&quot;version&quot;:&quot;0.0.1&quot;}&#39;)
  .expect(200, done);
</code></pre>
<p>unknown route respond with proper 404 and error message.</p>
<pre><code class="language-js">request(this.server)
  .get(&#39;/whatev&#39;)
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(&#39;{&quot;error&quot;:&quot;not_found&quot;,&quot;reason&quot;:&quot;no such route&quot;}&#39;)
  .expect(404, done);
</code></pre>
<p><a name="tiny-lr-get-changed" /></p>
<h2>GET /changed</h2><p>with no clients, no files.</p>
<pre><code class="language-js">request(this.server)
  .get(&#39;/changed&#39;)
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(/&quot;clients&quot;:\[\]/)
  .expect(/&quot;files&quot;:\[\]/)
  .expect(200, done);
</code></pre>
<p>with no clients, some files.</p>
<pre><code class="language-js">request(this.server)
  .get(&#39;/changed?files=gonna.css,test.css,it.css&#39;)
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(&#39;{&quot;clients&quot;:[],&quot;files&quot;:[&quot;gonna.css&quot;,&quot;test.css&quot;,&quot;it.css&quot;]}&#39;)
  .expect(200, done);
</code></pre>
<p><a name="tiny-lr-post-changed" /></p>
<h2>POST /changed</h2><p>with no clients, no files.</p>
<pre><code class="language-js">request(this.server)
  .post(&#39;/changed&#39;)
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(/&quot;clients&quot;:\[\]/)
  .expect(/&quot;files&quot;:\[\]/)
  .expect(200, done);
</code></pre>
<p>with no clients, some files.</p>
<pre><code class="language-js">var data = { clients: [], files: [&#39;cat.css&#39;, &#39;sed.css&#39;, &#39;ack.js&#39;] };

request(this.server)
  .post(&#39;/changed&#39;)
  .send({ files: data.files })
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(JSON.stringify(data))
  .expect(200, done);
</code></pre>
<p><a name="tiny-lr-get-livereloadjs" /></p>
<h2>GET /livereload.js</h2><p>respond with livereload script.</p>
<pre><code class="language-js">request(this.server)
  .get(&#39;/livereload.js&#39;)
  .expect(/LiveReload/)
  .expect(200, done);
</code></pre>
<p><a name="tiny-lr-get-kill" /></p>
<h2>GET /kill</h2><p>shutdown the server.</p>
<pre><code class="language-js">var server = this.server;
request(server)
  .get(&#39;/kill&#39;)
  .expect(200, function(err) {
    if(err) return done(err);
    assert.ok(!server._handle);
    done();
  });
</code></pre>
<h2>Thanks!</h2><ul>
<li><p>Tiny-lr is a <a href="http://livereload.com/">LiveReload</a> implementation. They
really made frontend editing better for a lot of us. They have a
<a href="https://itunes.apple.com/us/app/livereload/id482898991">LiveReload App on the Mac App Store</a>
you might want to check out.</p>
</li>
<li><p>To all <a href="https://github.com/mklabs/tiny-lr/graphs/contributors">contributors</a></p>
</li>
<li><p><a href="https://github.com/FGRibreau">@FGRibreau</a> / <a href="https://gist.github.com/1846952">pid.js
gist</a>) for the background friendly
bin wrapper, used in <a href="https://github.com/mklabs/make-livereload">make-livereload</a></p>
</li>
</ul>
